/*!
 * devextreme-react
 * Version: 23.2.5
 * Build date: Mon Mar 11 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-react
 */

/// <reference types="react" />
import dxForm, { Properties } from "devextreme/ui/form";
import { Component as BaseComponent, IHtmlOptions } from "./core/component";
import NestedOption from "./core/nested-option";
import type { ContentReadyEvent, DisposingEvent, EditorEnterKeyEvent, InitializedEvent, dxFormButtonItem, dxFormEmptyItem, dxFormGroupItem, dxFormSimpleItem, dxFormTabbedItem } from "devextreme/ui/form";
import type { ContentReadyEvent as ButtonContentReadyEvent, DisposingEvent as ButtonDisposingEvent, InitializedEvent as ButtonInitializedEvent, dxButtonOptions, ClickEvent, OptionChangedEvent } from "devextreme/ui/button";
import type { ContentReadyEvent as TabPanelContentReadyEvent, DisposingEvent as TabPanelDisposingEvent, InitializedEvent as TabPanelInitializedEvent, OptionChangedEvent as TabPanelOptionChangedEvent, dxTabPanelOptions, dxTabPanelItem, ItemClickEvent, ItemContextMenuEvent, ItemHoldEvent, ItemRenderedEvent, SelectionChangedEvent, TitleClickEvent, TitleHoldEvent, TitleRenderedEvent } from "devextreme/ui/tab_panel";
import type { template } from "devextreme/core/templates/template";
import type { CollectionWidgetItem } from "devextreme/ui/collection/ui.collection_widget.base";
import type { DataSourceOptions } from "devextreme/data/data_source";
import type { Store } from "devextreme/data/store";
import type DataSource from "devextreme/data/data_source";
import type * as CommonTypes from "devextreme/common";
declare type ReplaceFieldTypes<TSource, TReplacement> = {
    [P in keyof TSource]: P extends keyof TReplacement ? TReplacement[P] : TSource[P];
};
declare type IFormOptionsNarrowedEvents = {
    onContentReady?: ((e: ContentReadyEvent) => void);
    onDisposing?: ((e: DisposingEvent) => void);
    onEditorEnterKey?: ((e: EditorEnterKeyEvent) => void);
    onInitialized?: ((e: InitializedEvent) => void);
};
declare type IFormOptions = React.PropsWithChildren<ReplaceFieldTypes<Properties, IFormOptionsNarrowedEvents> & IHtmlOptions & {
    defaultFormData?: any;
    onFormDataChange?: (value: any) => void;
}>;
declare class Form extends BaseComponent<React.PropsWithChildren<IFormOptions>> {
    get instance(): dxForm;
    protected _WidgetClass: typeof dxForm;
    protected subscribableOptions: string[];
    protected independentEvents: string[];
    protected _defaults: {
        defaultFormData: string;
    };
    protected _expectedChildren: {
        ButtonItem: {
            optionName: string;
            isCollectionItem: boolean;
        };
        colCountByScreen: {
            optionName: string;
            isCollectionItem: boolean;
        };
        EmptyItem: {
            optionName: string;
            isCollectionItem: boolean;
        };
        GroupItem: {
            optionName: string;
            isCollectionItem: boolean;
        };
        item: {
            optionName: string;
            isCollectionItem: boolean;
        };
        SimpleItem: {
            optionName: string;
            isCollectionItem: boolean;
        };
        TabbedItem: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type IAsyncRuleProps = React.PropsWithChildren<{
    ignoreEmptyValue?: boolean;
    message?: string;
    reevaluate?: boolean;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
    validationCallback?: ((options: {
        column: Record<string, any>;
        data: Record<string, any>;
        formItem: Record<string, any>;
        rule: Record<string, any>;
        validator: Record<string, any>;
        value: string | number;
    }) => any);
}>;
declare class AsyncRule extends NestedOption<IAsyncRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type IButtonItemProps = React.PropsWithChildren<{
    buttonOptions?: dxButtonOptions;
    colSpan?: number;
    cssClass?: string;
    horizontalAlignment?: "center" | "left" | "right";
    itemType?: "empty" | "group" | "simple" | "tabbed" | "button";
    name?: string;
    verticalAlignment?: "bottom" | "center" | "top";
    visible?: boolean;
    visibleIndex?: number;
}>;
declare class ButtonItem extends NestedOption<IButtonItemProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static ExpectedChildren: {
        buttonOptions: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
    static PredefinedProps: {
        itemType: string;
    };
}
declare type IButtonOptionsProps = React.PropsWithChildren<{
    accessKey?: string;
    activeStateEnabled?: boolean;
    bindingOptions?: Record<string, any>;
    disabled?: boolean;
    elementAttr?: Record<string, any>;
    focusStateEnabled?: boolean;
    height?: (() => number | string) | number | string;
    hint?: string;
    hoverStateEnabled?: boolean;
    icon?: string;
    onClick?: ((e: ClickEvent) => void);
    onContentReady?: ((e: ButtonContentReadyEvent) => void);
    onDisposing?: ((e: ButtonDisposingEvent) => void);
    onInitialized?: ((e: ButtonInitializedEvent) => void);
    onOptionChanged?: ((e: OptionChangedEvent) => void);
    rtlEnabled?: boolean;
    stylingMode?: "text" | "outlined" | "contained";
    tabIndex?: number;
    template?: ((buttonData: {
        icon: string;
        text: string;
    }, contentElement: any) => string | any) | template;
    text?: string;
    type?: "danger" | "default" | "normal" | "success";
    useSubmitBehavior?: boolean;
    validationGroup?: string;
    visible?: boolean;
    width?: (() => number | string) | number | string;
    render?: (...params: any) => React.ReactNode;
    component?: React.ComponentType<any>;
    keyFn?: (data: any) => string;
}>;
declare class ButtonOptions extends NestedOption<IButtonOptionsProps> {
    static OptionName: string;
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type IColCountByScreenProps = React.PropsWithChildren<{
    lg?: number;
    md?: number;
    sm?: number;
    xs?: number;
}>;
declare class ColCountByScreen extends NestedOption<IColCountByScreenProps> {
    static OptionName: string;
}
declare type ICompareRuleProps = React.PropsWithChildren<{
    comparisonTarget?: (() => any);
    comparisonType?: "!=" | "!==" | "<" | "<=" | "==" | "===" | ">" | ">=";
    ignoreEmptyValue?: boolean;
    message?: string;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
}>;
declare class CompareRule extends NestedOption<ICompareRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type ICustomRuleProps = React.PropsWithChildren<{
    ignoreEmptyValue?: boolean;
    message?: string;
    reevaluate?: boolean;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
    validationCallback?: ((options: {
        column: Record<string, any>;
        data: Record<string, any>;
        formItem: Record<string, any>;
        rule: Record<string, any>;
        validator: Record<string, any>;
        value: string | number;
    }) => boolean);
}>;
declare class CustomRule extends NestedOption<ICustomRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type IEmailRuleProps = React.PropsWithChildren<{
    ignoreEmptyValue?: boolean;
    message?: string;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
}>;
declare class EmailRule extends NestedOption<IEmailRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type IEmptyItemProps = React.PropsWithChildren<{
    colSpan?: number;
    cssClass?: string;
    itemType?: "empty" | "group" | "simple" | "tabbed" | "button";
    name?: string;
    visible?: boolean;
    visibleIndex?: number;
}>;
declare class EmptyItem extends NestedOption<IEmptyItemProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        itemType: string;
    };
}
declare type IGroupItemProps = React.PropsWithChildren<{
    alignItemLabels?: boolean;
    caption?: string;
    colCount?: number;
    colCountByScreen?: Record<string, any> | {
        lg?: number;
        md?: number;
        sm?: number;
        xs?: number;
    };
    colSpan?: number;
    cssClass?: string;
    items?: Array<dxFormButtonItem | dxFormEmptyItem | dxFormGroupItem | dxFormSimpleItem | dxFormTabbedItem>;
    itemType?: "empty" | "group" | "simple" | "tabbed" | "button";
    name?: string;
    template?: ((data: {
        component: dxForm;
        formData: Record<string, any>;
    }, itemElement: any) => string | any) | template;
    visible?: boolean;
    visibleIndex?: number;
    render?: (...params: any) => React.ReactNode;
    component?: React.ComponentType<any>;
    keyFn?: (data: any) => string;
}>;
declare class GroupItem extends NestedOption<IGroupItemProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static ExpectedChildren: {
        colCountByScreen: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
    static PredefinedProps: {
        itemType: string;
    };
}
declare type IItemProps = React.PropsWithChildren<{
    badge?: string;
    disabled?: boolean;
    html?: string;
    icon?: string;
    tabTemplate?: (() => string | any) | template;
    template?: ((itemData: CollectionWidgetItem, itemIndex: number, itemElement: any) => string | any) | template;
    text?: string;
    title?: string;
    colSpan?: number;
    cssClass?: string;
    dataField?: string;
    editorOptions?: any;
    editorType?: "dxAutocomplete" | "dxCalendar" | "dxCheckBox" | "dxColorBox" | "dxDateBox" | "dxDateRangeBox" | "dxDropDownBox" | "dxHtmlEditor" | "dxLookup" | "dxNumberBox" | "dxRadioGroup" | "dxRangeSlider" | "dxSelectBox" | "dxSlider" | "dxSwitch" | "dxTagBox" | "dxTextArea" | "dxTextBox";
    helpText?: string;
    isRequired?: boolean;
    itemType?: "empty" | "group" | "simple" | "tabbed" | "button";
    label?: Record<string, any> | {
        alignment?: "center" | "left" | "right";
        location?: "left" | "right" | "top";
        showColon?: boolean;
        template?: ((itemData: {
            component: dxForm;
            dataField: string;
            editorOptions: any;
            editorType: string;
            name: string;
            text: string;
        }, itemElement: any) => string | any) | template;
        text?: string;
        visible?: boolean;
    };
    name?: string;
    validationRules?: Array<CommonTypes.ValidationRule>;
    visible?: boolean;
    visibleIndex?: number;
    alignItemLabels?: boolean;
    caption?: string;
    colCount?: number;
    colCountByScreen?: Record<string, any> | {
        lg?: number;
        md?: number;
        sm?: number;
        xs?: number;
    };
    items?: Array<dxFormButtonItem | dxFormEmptyItem | dxFormGroupItem | dxFormSimpleItem | dxFormTabbedItem>;
    tabPanelOptions?: dxTabPanelOptions;
    tabs?: Array<Record<string, any>> | {
        alignItemLabels?: boolean;
        badge?: string;
        colCount?: number;
        colCountByScreen?: Record<string, any> | {
            lg?: number;
            md?: number;
            sm?: number;
            xs?: number;
        };
        disabled?: boolean;
        icon?: string;
        items?: Array<dxFormButtonItem | dxFormEmptyItem | dxFormGroupItem | dxFormSimpleItem | dxFormTabbedItem>;
        tabTemplate?: ((tabData: any, tabIndex: number, tabElement: any) => any) | template;
        template?: ((tabData: any, tabIndex: number, tabElement: any) => any) | template;
        title?: string;
    }[];
    buttonOptions?: dxButtonOptions;
    horizontalAlignment?: "center" | "left" | "right";
    verticalAlignment?: "bottom" | "center" | "top";
    tabRender?: (...params: any) => React.ReactNode;
    tabComponent?: React.ComponentType<any>;
    tabKeyFn?: (data: any) => string;
    render?: (...params: any) => React.ReactNode;
    component?: React.ComponentType<any>;
    keyFn?: (data: any) => string;
}>;
declare class Item extends NestedOption<IItemProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type ILabelProps = React.PropsWithChildren<{
    alignment?: "center" | "left" | "right";
    location?: "left" | "right" | "top";
    showColon?: boolean;
    template?: ((itemData: {
        component: dxForm;
        dataField: string;
        editorOptions: any;
        editorType: string;
        name: string;
        text: string;
    }, itemElement: any) => string | any) | template;
    text?: string;
    visible?: boolean;
    render?: (...params: any) => React.ReactNode;
    component?: React.ComponentType<any>;
    keyFn?: (data: any) => string;
}>;
declare class Label extends NestedOption<ILabelProps> {
    static OptionName: string;
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type INumericRuleProps = React.PropsWithChildren<{
    ignoreEmptyValue?: boolean;
    message?: string;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
}>;
declare class NumericRule extends NestedOption<INumericRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type IPatternRuleProps = React.PropsWithChildren<{
    ignoreEmptyValue?: boolean;
    message?: string;
    pattern?: RegExp | string;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
}>;
declare class PatternRule extends NestedOption<IPatternRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type IRangeRuleProps = React.PropsWithChildren<{
    ignoreEmptyValue?: boolean;
    max?: Date | number | string;
    message?: string;
    min?: Date | number | string;
    reevaluate?: boolean;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
}>;
declare class RangeRule extends NestedOption<IRangeRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type IRequiredRuleProps = React.PropsWithChildren<{
    message?: string;
    trim?: boolean;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
}>;
declare class RequiredRule extends NestedOption<IRequiredRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type ISimpleItemProps = React.PropsWithChildren<{
    colSpan?: number;
    cssClass?: string;
    dataField?: string;
    editorOptions?: any;
    editorType?: "dxAutocomplete" | "dxCalendar" | "dxCheckBox" | "dxColorBox" | "dxDateBox" | "dxDateRangeBox" | "dxDropDownBox" | "dxHtmlEditor" | "dxLookup" | "dxNumberBox" | "dxRadioGroup" | "dxRangeSlider" | "dxSelectBox" | "dxSlider" | "dxSwitch" | "dxTagBox" | "dxTextArea" | "dxTextBox";
    helpText?: string;
    isRequired?: boolean;
    itemType?: "empty" | "group" | "simple" | "tabbed" | "button";
    label?: Record<string, any> | {
        alignment?: "center" | "left" | "right";
        location?: "left" | "right" | "top";
        showColon?: boolean;
        template?: ((itemData: {
            component: dxForm;
            dataField: string;
            editorOptions: any;
            editorType: string;
            name: string;
            text: string;
        }, itemElement: any) => string | any) | template;
        text?: string;
        visible?: boolean;
    };
    name?: string;
    template?: ((data: {
        component: dxForm;
        dataField: string;
        editorOptions: Record<string, any>;
        editorType: string;
        name: string;
    }, itemElement: any) => string | any) | template;
    validationRules?: Array<CommonTypes.ValidationRule>;
    visible?: boolean;
    visibleIndex?: number;
    render?: (...params: any) => React.ReactNode;
    component?: React.ComponentType<any>;
    keyFn?: (data: any) => string;
}>;
declare class SimpleItem extends NestedOption<ISimpleItemProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static ExpectedChildren: {
        AsyncRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        CompareRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        CustomRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        EmailRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        label: {
            optionName: string;
            isCollectionItem: boolean;
        };
        NumericRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        PatternRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        RangeRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        RequiredRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        StringLengthRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        validationRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
    static PredefinedProps: {
        itemType: string;
    };
}
declare type IStringLengthRuleProps = React.PropsWithChildren<{
    ignoreEmptyValue?: boolean;
    max?: number;
    message?: string;
    min?: number;
    trim?: boolean;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
}>;
declare class StringLengthRule extends NestedOption<IStringLengthRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type ITabProps = React.PropsWithChildren<{
    alignItemLabels?: boolean;
    badge?: string;
    colCount?: number;
    colCountByScreen?: Record<string, any> | {
        lg?: number;
        md?: number;
        sm?: number;
        xs?: number;
    };
    disabled?: boolean;
    icon?: string;
    items?: Array<dxFormButtonItem | dxFormEmptyItem | dxFormGroupItem | dxFormSimpleItem | dxFormTabbedItem>;
    tabTemplate?: ((tabData: any, tabIndex: number, tabElement: any) => any) | template;
    template?: ((tabData: any, tabIndex: number, tabElement: any) => any) | template;
    title?: string;
    tabRender?: (...params: any) => React.ReactNode;
    tabComponent?: React.ComponentType<any>;
    tabKeyFn?: (data: any) => string;
    render?: (...params: any) => React.ReactNode;
    component?: React.ComponentType<any>;
    keyFn?: (data: any) => string;
}>;
declare class Tab extends NestedOption<ITabProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static ExpectedChildren: {
        colCountByScreen: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type ITabbedItemProps = React.PropsWithChildren<{
    colSpan?: number;
    cssClass?: string;
    itemType?: "empty" | "group" | "simple" | "tabbed" | "button";
    name?: string;
    tabPanelOptions?: dxTabPanelOptions;
    tabs?: Array<Record<string, any>> | {
        alignItemLabels?: boolean;
        badge?: string;
        colCount?: number;
        colCountByScreen?: Record<string, any> | {
            lg?: number;
            md?: number;
            sm?: number;
            xs?: number;
        };
        disabled?: boolean;
        icon?: string;
        items?: Array<dxFormButtonItem | dxFormEmptyItem | dxFormGroupItem | dxFormSimpleItem | dxFormTabbedItem>;
        tabTemplate?: ((tabData: any, tabIndex: number, tabElement: any) => any) | template;
        template?: ((tabData: any, tabIndex: number, tabElement: any) => any) | template;
        title?: string;
    }[];
    visible?: boolean;
    visibleIndex?: number;
}>;
declare class TabbedItem extends NestedOption<ITabbedItemProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static ExpectedChildren: {
        tab: {
            optionName: string;
            isCollectionItem: boolean;
        };
        tabPanelOptions: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
    static PredefinedProps: {
        itemType: string;
    };
}
declare type ITabPanelOptionsProps = React.PropsWithChildren<{
    accessKey?: string;
    activeStateEnabled?: boolean;
    animationEnabled?: boolean;
    bindingOptions?: Record<string, any>;
    dataSource?: Array<any | dxTabPanelItem | string> | DataSource | DataSourceOptions | null | Store | string;
    deferRendering?: boolean;
    disabled?: boolean;
    elementAttr?: Record<string, any>;
    focusStateEnabled?: boolean;
    height?: (() => number | string) | number | string;
    hint?: string;
    hoverStateEnabled?: boolean;
    iconPosition?: "top" | "end" | "bottom" | "start";
    itemHoldTimeout?: number;
    items?: Array<any | dxTabPanelItem | string>;
    itemTemplate?: ((itemData: any, itemIndex: number, itemElement: any) => string | any) | template;
    itemTitleTemplate?: ((itemData: any, itemIndex: number, itemElement: any) => string | any) | template;
    loop?: boolean;
    noDataText?: string;
    onContentReady?: ((e: TabPanelContentReadyEvent) => void);
    onDisposing?: ((e: TabPanelDisposingEvent) => void);
    onInitialized?: ((e: TabPanelInitializedEvent) => void);
    onItemClick?: ((e: ItemClickEvent) => void);
    onItemContextMenu?: ((e: ItemContextMenuEvent) => void);
    onItemHold?: ((e: ItemHoldEvent) => void);
    onItemRendered?: ((e: ItemRenderedEvent) => void);
    onOptionChanged?: ((e: TabPanelOptionChangedEvent) => void);
    onSelectionChanged?: ((e: SelectionChangedEvent) => void);
    onTitleClick?: ((e: TitleClickEvent) => void);
    onTitleHold?: ((e: TitleHoldEvent) => void);
    onTitleRendered?: ((e: TitleRenderedEvent) => void);
    repaintChangesOnly?: boolean;
    rtlEnabled?: boolean;
    scrollByContent?: boolean;
    scrollingEnabled?: boolean;
    selectedIndex?: number;
    selectedItem?: any;
    showNavButtons?: boolean;
    stylingMode?: "primary" | "secondary";
    swipeEnabled?: boolean;
    tabIndex?: number;
    tabsPosition?: "bottom" | "left" | "right" | "top";
    visible?: boolean;
    width?: (() => number | string) | number | string;
    defaultItems?: Array<any | dxTabPanelItem | string>;
    onItemsChange?: (value: Array<any | dxTabPanelItem | string>) => void;
    defaultSelectedIndex?: number;
    onSelectedIndexChange?: (value: number) => void;
    defaultSelectedItem?: any;
    onSelectedItemChange?: (value: any) => void;
    itemRender?: (...params: any) => React.ReactNode;
    itemComponent?: React.ComponentType<any>;
    itemKeyFn?: (data: any) => string;
    itemTitleRender?: (...params: any) => React.ReactNode;
    itemTitleComponent?: React.ComponentType<any>;
    itemTitleKeyFn?: (data: any) => string;
}>;
declare class TabPanelOptions extends NestedOption<ITabPanelOptionsProps> {
    static OptionName: string;
    static DefaultsProps: {
        defaultItems: string;
        defaultSelectedIndex: string;
        defaultSelectedItem: string;
    };
    static ExpectedChildren: {
        item: {
            optionName: string;
            isCollectionItem: boolean;
        };
        tabPanelOptionsItem: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type ITabPanelOptionsItemProps = React.PropsWithChildren<{
    badge?: string;
    disabled?: boolean;
    html?: string;
    icon?: string;
    tabTemplate?: (() => string | any) | template;
    template?: ((itemData: CollectionWidgetItem, itemIndex: number, itemElement: any) => string | any) | template;
    text?: string;
    title?: string;
    tabRender?: (...params: any) => React.ReactNode;
    tabComponent?: React.ComponentType<any>;
    tabKeyFn?: (data: any) => string;
    render?: (...params: any) => React.ReactNode;
    component?: React.ComponentType<any>;
    keyFn?: (data: any) => string;
}>;
declare class TabPanelOptionsItem extends NestedOption<ITabPanelOptionsItemProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type IValidationRuleProps = React.PropsWithChildren<{
    message?: string;
    trim?: boolean;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
    ignoreEmptyValue?: boolean;
    max?: Date | number | string;
    min?: Date | number | string;
    reevaluate?: boolean;
    validationCallback?: ((options: {
        column: Record<string, any>;
        data: Record<string, any>;
        formItem: Record<string, any>;
        rule: Record<string, any>;
        validator: Record<string, any>;
        value: string | number;
    }) => boolean);
    comparisonTarget?: (() => any);
    comparisonType?: "!=" | "!==" | "<" | "<=" | "==" | "===" | ">" | ">=";
    pattern?: RegExp | string;
}>;
declare class ValidationRule extends NestedOption<IValidationRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
export default Form;
export { Form, IFormOptions, AsyncRule, IAsyncRuleProps, ButtonItem, IButtonItemProps, ButtonOptions, IButtonOptionsProps, ColCountByScreen, IColCountByScreenProps, CompareRule, ICompareRuleProps, CustomRule, ICustomRuleProps, EmailRule, IEmailRuleProps, EmptyItem, IEmptyItemProps, GroupItem, IGroupItemProps, Item, IItemProps, Label, ILabelProps, NumericRule, INumericRuleProps, PatternRule, IPatternRuleProps, RangeRule, IRangeRuleProps, RequiredRule, IRequiredRuleProps, SimpleItem, ISimpleItemProps, StringLengthRule, IStringLengthRuleProps, Tab, ITabProps, TabbedItem, ITabbedItemProps, TabPanelOptions, ITabPanelOptionsProps, TabPanelOptionsItem, ITabPanelOptionsItemProps, ValidationRule, IValidationRuleProps };
import type * as FormTypes from 'devextreme/ui/form_types';
export { FormTypes };
