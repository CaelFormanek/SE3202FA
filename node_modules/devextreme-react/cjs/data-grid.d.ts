/*!
 * devextreme-react
 * Version: 23.2.5
 * Build date: Mon Mar 11 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-react
 */

/// <reference types="react" />
export { ExplicitTypes } from "devextreme/ui/data_grid";
import dxDataGrid, { Properties } from "devextreme/ui/data_grid";
import { Component as BaseComponent, IHtmlOptions } from "./core/component";
import NestedOption from "./core/nested-option";
import type { dxDataGridColumn, AdaptiveDetailRowPreparingEvent, CellClickEvent, CellDblClickEvent, CellPreparedEvent, ContentReadyEvent, ContextMenuPreparingEvent, DataErrorOccurredEvent, DisposingEvent, EditCanceledEvent, EditCancelingEvent, EditingStartEvent, EditorPreparedEvent, EditorPreparingEvent, ExportingEvent, FocusedCellChangingEvent, FocusedRowChangingEvent, InitializedEvent, InitNewRowEvent, KeyDownEvent, RowClickEvent, RowCollapsedEvent, RowCollapsingEvent, RowDblClickEvent, RowExpandedEvent, RowExpandingEvent, RowInsertedEvent, RowInsertingEvent, RowPreparedEvent, RowRemovedEvent, RowRemovingEvent, RowUpdatedEvent, RowUpdatingEvent, RowValidatingEvent, SavedEvent, SavingEvent, ToolbarPreparingEvent, dxDataGridRowObject, ColumnButtonClickEvent, dxDataGridColumnButton, dxDataGridToolbarItem } from "devextreme/ui/data_grid";
import type { DataChange, ColumnHeaderFilterSearchConfig, ColumnChooserSearchConfig, ColumnChooserSelectionConfig, HeaderFilterSearchConfig, GridBase } from "devextreme/common/grids";
import type { ContentReadyEvent as FilterBuilderContentReadyEvent, DisposingEvent as FilterBuilderDisposingEvent, EditorPreparedEvent as FilterBuilderEditorPreparedEvent, EditorPreparingEvent as FilterBuilderEditorPreparingEvent, InitializedEvent as FilterBuilderInitializedEvent, dxFilterBuilderField, dxFilterBuilderCustomOperation, OptionChangedEvent, ValueChangedEvent } from "devextreme/ui/filter_builder";
import type { ContentReadyEvent as FormContentReadyEvent, DisposingEvent as FormDisposingEvent, InitializedEvent as FormInitializedEvent, dxFormSimpleItem, dxFormOptions, OptionChangedEvent as FormOptionChangedEvent, dxFormGroupItem, dxFormTabbedItem, dxFormEmptyItem, dxFormButtonItem, EditorEnterKeyEvent, FieldDataChangedEvent } from "devextreme/ui/form";
import type { AnimationConfig, AnimationState } from "devextreme/animation/fx";
import type { template } from "devextreme/core/templates/template";
import type { DataSourceOptions } from "devextreme/data/data_source";
import type { Store } from "devextreme/data/store";
import type { PositionConfig } from "devextreme/animation/position";
import type { dxPopupOptions, dxPopupToolbarItem } from "devextreme/ui/popup";
import type { event, EventInfo } from "devextreme/events/index";
import type { Component } from "devextreme/core/component";
import type { CollectionWidgetItem } from "devextreme/ui/collection/ui.collection_widget.base";
import type dxOverlay from "devextreme/ui/overlay";
import type DOMComponent from "devextreme/core/dom_component";
import type dxPopup from "devextreme/ui/popup";
import type dxForm from "devextreme/ui/form";
import type dxSortable from "devextreme/ui/sortable";
import type dxDraggable from "devextreme/ui/draggable";
import type * as LocalizationTypes from "devextreme/localization";
import type * as CommonTypes from "devextreme/common";
declare type ReplaceFieldTypes<TSource, TReplacement> = {
    [P in keyof TSource]: P extends keyof TReplacement ? TReplacement[P] : TSource[P];
};
declare type IDataGridOptionsNarrowedEvents<TRowData = any, TKey = any> = {
    onAdaptiveDetailRowPreparing?: ((e: AdaptiveDetailRowPreparingEvent<TRowData, TKey>) => void);
    onCellClick?: ((e: CellClickEvent<TRowData, TKey>) => void);
    onCellDblClick?: ((e: CellDblClickEvent<TRowData, TKey>) => void);
    onCellPrepared?: ((e: CellPreparedEvent<TRowData, TKey>) => void);
    onContentReady?: ((e: ContentReadyEvent<TRowData, TKey>) => void);
    onContextMenuPreparing?: ((e: ContextMenuPreparingEvent<TRowData, TKey>) => void);
    onDataErrorOccurred?: ((e: DataErrorOccurredEvent<TRowData, TKey>) => void);
    onDisposing?: ((e: DisposingEvent<TRowData, TKey>) => void);
    onEditCanceled?: ((e: EditCanceledEvent<TRowData, TKey>) => void);
    onEditCanceling?: ((e: EditCancelingEvent<TRowData, TKey>) => void);
    onEditingStart?: ((e: EditingStartEvent<TRowData, TKey>) => void);
    onEditorPrepared?: ((e: EditorPreparedEvent<TRowData, TKey>) => void);
    onEditorPreparing?: ((e: EditorPreparingEvent<TRowData, TKey>) => void);
    onExporting?: ((e: ExportingEvent<TRowData, TKey>) => void);
    onFocusedCellChanging?: ((e: FocusedCellChangingEvent<TRowData, TKey>) => void);
    onFocusedRowChanging?: ((e: FocusedRowChangingEvent<TRowData, TKey>) => void);
    onInitialized?: ((e: InitializedEvent<TRowData, TKey>) => void);
    onInitNewRow?: ((e: InitNewRowEvent<TRowData, TKey>) => void);
    onKeyDown?: ((e: KeyDownEvent<TRowData, TKey>) => void);
    onRowClick?: ((e: RowClickEvent<TRowData, TKey>) => void);
    onRowCollapsed?: ((e: RowCollapsedEvent<TRowData, TKey>) => void);
    onRowCollapsing?: ((e: RowCollapsingEvent<TRowData, TKey>) => void);
    onRowDblClick?: ((e: RowDblClickEvent<TRowData, TKey>) => void);
    onRowExpanded?: ((e: RowExpandedEvent<TRowData, TKey>) => void);
    onRowExpanding?: ((e: RowExpandingEvent<TRowData, TKey>) => void);
    onRowInserted?: ((e: RowInsertedEvent<TRowData, TKey>) => void);
    onRowInserting?: ((e: RowInsertingEvent<TRowData, TKey>) => void);
    onRowPrepared?: ((e: RowPreparedEvent<TRowData, TKey>) => void);
    onRowRemoved?: ((e: RowRemovedEvent<TRowData, TKey>) => void);
    onRowRemoving?: ((e: RowRemovingEvent<TRowData, TKey>) => void);
    onRowUpdated?: ((e: RowUpdatedEvent<TRowData, TKey>) => void);
    onRowUpdating?: ((e: RowUpdatingEvent<TRowData, TKey>) => void);
    onRowValidating?: ((e: RowValidatingEvent<TRowData, TKey>) => void);
    onSaved?: ((e: SavedEvent<TRowData, TKey>) => void);
    onSaving?: ((e: SavingEvent<TRowData, TKey>) => void);
    onToolbarPreparing?: ((e: ToolbarPreparingEvent<TRowData, TKey>) => void);
};
declare type IDataGridOptions<TRowData = any, TKey = any> = React.PropsWithChildren<ReplaceFieldTypes<Properties<TRowData, TKey>, IDataGridOptionsNarrowedEvents<TRowData, TKey>> & IHtmlOptions & {
    dataSource?: Properties<TRowData, TKey>["dataSource"];
    dataRowRender?: (...params: any) => React.ReactNode;
    dataRowComponent?: React.ComponentType<any>;
    dataRowKeyFn?: (data: any) => string;
    rowRender?: (...params: any) => React.ReactNode;
    rowComponent?: React.ComponentType<any>;
    rowKeyFn?: (data: any) => string;
    defaultColumns?: Array<dxDataGridColumn | string>;
    defaultEditing?: Record<string, any>;
    defaultFilterPanel?: Record<string, any>;
    defaultFilterValue?: Array<any> | (() => any) | string;
    defaultFocusedColumnIndex?: number;
    defaultFocusedRowIndex?: number;
    defaultFocusedRowKey?: any;
    defaultGroupPanel?: Record<string, any>;
    defaultPaging?: Record<string, any>;
    defaultSearchPanel?: Record<string, any>;
    defaultSelectedRowKeys?: Array<any>;
    defaultSelectionFilter?: Array<any> | (() => any) | string;
    onColumnsChange?: (value: Array<dxDataGridColumn | string>) => void;
    onEditingChange?: (value: Record<string, any>) => void;
    onFilterPanelChange?: (value: Record<string, any>) => void;
    onFilterValueChange?: (value: Array<any> | (() => any) | string) => void;
    onFocusedColumnIndexChange?: (value: number) => void;
    onFocusedRowIndexChange?: (value: number) => void;
    onFocusedRowKeyChange?: (value: any) => void;
    onGroupPanelChange?: (value: Record<string, any>) => void;
    onPagingChange?: (value: Record<string, any>) => void;
    onSearchPanelChange?: (value: Record<string, any>) => void;
    onSelectedRowKeysChange?: (value: Array<any>) => void;
    onSelectionFilterChange?: (value: Array<any> | (() => any) | string) => void;
}>;
declare class DataGrid<TRowData = any, TKey = any> extends BaseComponent<React.PropsWithChildren<IDataGridOptions<TRowData, TKey>>> {
    get instance(): dxDataGrid<TRowData, TKey>;
    protected _WidgetClass: typeof dxDataGrid;
    protected useRequestAnimationFrameFlag: boolean;
    protected subscribableOptions: string[];
    protected independentEvents: string[];
    protected _defaults: {
        defaultColumns: string;
        defaultEditing: string;
        defaultFilterPanel: string;
        defaultFilterValue: string;
        defaultFocusedColumnIndex: string;
        defaultFocusedRowIndex: string;
        defaultFocusedRowKey: string;
        defaultGroupPanel: string;
        defaultPaging: string;
        defaultSearchPanel: string;
        defaultSelectedRowKeys: string;
        defaultSelectionFilter: string;
    };
    protected _expectedChildren: {
        column: {
            optionName: string;
            isCollectionItem: boolean;
        };
        columnChooser: {
            optionName: string;
            isCollectionItem: boolean;
        };
        columnFixing: {
            optionName: string;
            isCollectionItem: boolean;
        };
        dataGridHeaderFilter: {
            optionName: string;
            isCollectionItem: boolean;
        };
        dataGridSelection: {
            optionName: string;
            isCollectionItem: boolean;
        };
        editing: {
            optionName: string;
            isCollectionItem: boolean;
        };
        export: {
            optionName: string;
            isCollectionItem: boolean;
        };
        filterBuilder: {
            optionName: string;
            isCollectionItem: boolean;
        };
        filterBuilderPopup: {
            optionName: string;
            isCollectionItem: boolean;
        };
        filterPanel: {
            optionName: string;
            isCollectionItem: boolean;
        };
        filterRow: {
            optionName: string;
            isCollectionItem: boolean;
        };
        grouping: {
            optionName: string;
            isCollectionItem: boolean;
        };
        groupPanel: {
            optionName: string;
            isCollectionItem: boolean;
        };
        headerFilter: {
            optionName: string;
            isCollectionItem: boolean;
        };
        keyboardNavigation: {
            optionName: string;
            isCollectionItem: boolean;
        };
        loadPanel: {
            optionName: string;
            isCollectionItem: boolean;
        };
        masterDetail: {
            optionName: string;
            isCollectionItem: boolean;
        };
        pager: {
            optionName: string;
            isCollectionItem: boolean;
        };
        paging: {
            optionName: string;
            isCollectionItem: boolean;
        };
        remoteOperations: {
            optionName: string;
            isCollectionItem: boolean;
        };
        rowDragging: {
            optionName: string;
            isCollectionItem: boolean;
        };
        scrolling: {
            optionName: string;
            isCollectionItem: boolean;
        };
        searchPanel: {
            optionName: string;
            isCollectionItem: boolean;
        };
        selection: {
            optionName: string;
            isCollectionItem: boolean;
        };
        sortByGroupSummaryInfo: {
            optionName: string;
            isCollectionItem: boolean;
        };
        sorting: {
            optionName: string;
            isCollectionItem: boolean;
        };
        stateStoring: {
            optionName: string;
            isCollectionItem: boolean;
        };
        summary: {
            optionName: string;
            isCollectionItem: boolean;
        };
        toolbar: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
    protected _templateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type IAnimationProps = React.PropsWithChildren<{
    hide?: AnimationConfig;
    show?: AnimationConfig;
}>;
declare class Animation extends NestedOption<IAnimationProps> {
    static OptionName: string;
    static ExpectedChildren: {
        hide: {
            optionName: string;
            isCollectionItem: boolean;
        };
        show: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type IAsyncRuleProps = React.PropsWithChildren<{
    ignoreEmptyValue?: boolean;
    message?: string;
    reevaluate?: boolean;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
    validationCallback?: ((options: {
        column: Record<string, any>;
        data: Record<string, any>;
        formItem: Record<string, any>;
        rule: Record<string, any>;
        validator: Record<string, any>;
        value: string | number;
    }) => any);
}>;
declare class AsyncRule extends NestedOption<IAsyncRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type IAtProps = React.PropsWithChildren<{
    x?: "center" | "left" | "right";
    y?: "bottom" | "center" | "top";
}>;
declare class At extends NestedOption<IAtProps> {
    static OptionName: string;
}
declare type IBoundaryOffsetProps = React.PropsWithChildren<{
    x?: number;
    y?: number;
}>;
declare class BoundaryOffset extends NestedOption<IBoundaryOffsetProps> {
    static OptionName: string;
}
declare type IButtonProps = React.PropsWithChildren<{
    cssClass?: string;
    disabled?: boolean | ((options: {
        column: dxDataGridColumn;
        component: dxDataGrid;
        row: dxDataGridRowObject;
    }) => boolean);
    hint?: string;
    icon?: string;
    name?: "cancel" | "delete" | "edit" | "save" | "undelete";
    onClick?: ((e: ColumnButtonClickEvent) => void);
    template?: ((cellElement: any, cellInfo: {
        column: dxDataGridColumn;
        columnIndex: number;
        component: dxDataGrid;
        data: Record<string, any>;
        key: any;
        row: dxDataGridRowObject;
        rowIndex: number;
        rowType: string;
    }) => string | any) | template;
    text?: string;
    visible?: boolean | ((options: {
        column: dxDataGridColumn;
        component: dxDataGrid;
        row: dxDataGridRowObject;
    }) => boolean);
    render?: (...params: any) => React.ReactNode;
    component?: React.ComponentType<any>;
    keyFn?: (data: any) => string;
}>;
declare class Button extends NestedOption<IButtonProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type IChangeProps = React.PropsWithChildren<{
    data?: any;
    insertAfterKey?: any;
    insertBeforeKey?: any;
    key?: any;
    type?: "insert" | "update" | "remove";
}>;
declare class Change extends NestedOption<IChangeProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
}
declare type IColCountByScreenProps = React.PropsWithChildren<{
    lg?: number;
    md?: number;
    sm?: number;
    xs?: number;
}>;
declare class ColCountByScreen extends NestedOption<IColCountByScreenProps> {
    static OptionName: string;
}
declare type ICollisionProps = React.PropsWithChildren<{
    x?: "fit" | "flip" | "flipfit" | "none";
    y?: "fit" | "flip" | "flipfit" | "none";
}>;
declare class Collision extends NestedOption<ICollisionProps> {
    static OptionName: string;
}
declare type IColumnProps = React.PropsWithChildren<{
    alignment?: "center" | "left" | "right";
    allowEditing?: boolean;
    allowExporting?: boolean;
    allowFiltering?: boolean;
    allowFixing?: boolean;
    allowGrouping?: boolean;
    allowHeaderFiltering?: boolean;
    allowHiding?: boolean;
    allowReordering?: boolean;
    allowResizing?: boolean;
    allowSearch?: boolean;
    allowSorting?: boolean;
    autoExpandGroup?: boolean;
    buttons?: Array<dxDataGridColumnButton | "cancel" | "delete" | "edit" | "save" | "undelete">;
    calculateCellValue?: ((rowData: any) => any);
    calculateDisplayValue?: ((rowData: any) => any) | string;
    calculateFilterExpression?: ((filterValue: any, selectedFilterOperation: string | null, target: string) => string | (() => any) | Array<any>);
    calculateGroupValue?: ((rowData: any) => any) | string;
    calculateSortValue?: ((rowData: any) => any) | string;
    caption?: string;
    cellTemplate?: ((cellElement: any, cellInfo: {
        column: dxDataGridColumn;
        columnIndex: number;
        component: dxDataGrid;
        data: Record<string, any>;
        displayValue: any;
        oldValue: any;
        row: dxDataGridRowObject;
        rowIndex: number;
        rowType: string;
        text: string;
        value: any;
        watch: (() => void);
    }) => any) | template;
    columns?: Array<dxDataGridColumn | string>;
    cssClass?: string;
    customizeText?: ((cellInfo: {
        groupInterval: string | number;
        target: string;
        value: any;
        valueText: string;
    }) => string);
    dataField?: string;
    dataType?: "string" | "number" | "date" | "boolean" | "object" | "datetime";
    editCellTemplate?: ((cellElement: any, cellInfo: {
        column: dxDataGridColumn;
        columnIndex: number;
        component: dxDataGrid;
        data: Record<string, any>;
        displayValue: any;
        row: dxDataGridRowObject;
        rowIndex: number;
        rowType: string;
        setValue(newValue: any, newText: any): any;
        text: string;
        value: any;
        watch: (() => void);
    }) => any) | template;
    editorOptions?: any;
    encodeHtml?: boolean;
    falseText?: string;
    filterOperations?: Array<"=" | "<>" | "<" | "<=" | ">" | ">=" | "contains" | "endswith" | "isblank" | "isnotblank" | "notcontains" | "startswith" | "between" | "anyof" | "noneof" | string>;
    filterType?: "exclude" | "include";
    filterValue?: any;
    filterValues?: Array<any>;
    fixed?: boolean;
    fixedPosition?: "left" | "right";
    format?: LocalizationTypes.Format;
    formItem?: dxFormSimpleItem;
    groupCellTemplate?: ((cellElement: any, cellInfo: {
        column: dxDataGridColumn;
        columnIndex: number;
        component: dxDataGrid;
        data: Record<string, any>;
        displayValue: any;
        groupContinuedMessage: string;
        groupContinuesMessage: string;
        row: dxDataGridRowObject;
        rowIndex: number;
        summaryItems: Array<any>;
        text: string;
        value: any;
    }) => any) | template;
    groupIndex?: number;
    headerCellTemplate?: ((columnHeader: any, headerInfo: {
        column: dxDataGridColumn;
        columnIndex: number;
        component: dxDataGrid;
    }) => any) | template;
    headerFilter?: Record<string, any> | {
        allowSearch?: boolean;
        allowSelectAll?: boolean;
        dataSource?: Array<any> | DataSourceOptions | ((options: {
            component: Record<string, any>;
            dataSource: DataSourceOptions | null;
        }) => void) | null | Store;
        groupInterval?: number | "day" | "hour" | "minute" | "month" | "quarter" | "second" | "year";
        height?: number | string;
        search?: ColumnHeaderFilterSearchConfig;
        searchMode?: "contains" | "startswith" | "equals";
        width?: number | string;
    };
    hidingPriority?: number;
    isBand?: boolean;
    lookup?: Record<string, any> | {
        allowClearing?: boolean;
        calculateCellValue?: ((rowData: any) => any);
        dataSource?: Array<any> | DataSourceOptions | ((options: {
            data: Record<string, any>;
            key: any;
        }) => Array<any> | Store | DataSourceOptions) | null | Store;
        displayExpr?: ((data: any) => string) | string;
        valueExpr?: string;
    };
    minWidth?: number;
    name?: string;
    ownerBand?: number;
    renderAsync?: boolean;
    selectedFilterOperation?: "<" | "<=" | "<>" | "=" | ">" | ">=" | "between" | "contains" | "endswith" | "notcontains" | "startswith";
    setCellValue?: ((newData: any, value: any, currentRowData: any) => any);
    showEditorAlways?: boolean;
    showInColumnChooser?: boolean;
    showWhenGrouped?: boolean;
    sortIndex?: number;
    sortingMethod?: ((value1: any, value2: any) => number);
    sortOrder?: "asc" | "desc";
    trueText?: string;
    type?: "adaptive" | "buttons" | "detailExpand" | "groupExpand" | "selection" | "drag";
    validationRules?: Array<CommonTypes.ValidationRule>;
    visible?: boolean;
    visibleIndex?: number;
    width?: number | string;
    defaultFilterValue?: any;
    onFilterValueChange?: (value: any) => void;
    defaultFilterValues?: Array<any>;
    onFilterValuesChange?: (value: Array<any>) => void;
    defaultGroupIndex?: number;
    onGroupIndexChange?: (value: number) => void;
    defaultSelectedFilterOperation?: "<" | "<=" | "<>" | "=" | ">" | ">=" | "between" | "contains" | "endswith" | "notcontains" | "startswith";
    onSelectedFilterOperationChange?: (value: "<" | "<=" | "<>" | "=" | ">" | ">=" | "between" | "contains" | "endswith" | "notcontains" | "startswith") => void;
    defaultSortIndex?: number;
    onSortIndexChange?: (value: number) => void;
    defaultSortOrder?: "asc" | "desc";
    onSortOrderChange?: (value: "asc" | "desc") => void;
    defaultVisible?: boolean;
    onVisibleChange?: (value: boolean) => void;
    defaultVisibleIndex?: number;
    onVisibleIndexChange?: (value: number) => void;
    cellRender?: (...params: any) => React.ReactNode;
    cellComponent?: React.ComponentType<any>;
    cellKeyFn?: (data: any) => string;
    editCellRender?: (...params: any) => React.ReactNode;
    editCellComponent?: React.ComponentType<any>;
    editCellKeyFn?: (data: any) => string;
    groupCellRender?: (...params: any) => React.ReactNode;
    groupCellComponent?: React.ComponentType<any>;
    groupCellKeyFn?: (data: any) => string;
    headerCellRender?: (...params: any) => React.ReactNode;
    headerCellComponent?: React.ComponentType<any>;
    headerCellKeyFn?: (data: any) => string;
}>;
declare class Column extends NestedOption<IColumnProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static DefaultsProps: {
        defaultFilterValue: string;
        defaultFilterValues: string;
        defaultGroupIndex: string;
        defaultSelectedFilterOperation: string;
        defaultSortIndex: string;
        defaultSortOrder: string;
        defaultVisible: string;
        defaultVisibleIndex: string;
    };
    static ExpectedChildren: {
        AsyncRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        button: {
            optionName: string;
            isCollectionItem: boolean;
        };
        columnHeaderFilter: {
            optionName: string;
            isCollectionItem: boolean;
        };
        columnLookup: {
            optionName: string;
            isCollectionItem: boolean;
        };
        CompareRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        CustomRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        EmailRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        format: {
            optionName: string;
            isCollectionItem: boolean;
        };
        formItem: {
            optionName: string;
            isCollectionItem: boolean;
        };
        headerFilter: {
            optionName: string;
            isCollectionItem: boolean;
        };
        lookup: {
            optionName: string;
            isCollectionItem: boolean;
        };
        NumericRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        PatternRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        RangeRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        RequiredRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        StringLengthRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        validationRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type IColumnChooserProps = React.PropsWithChildren<{
    allowSearch?: boolean;
    container?: any | string;
    emptyPanelText?: string;
    enabled?: boolean;
    height?: number | string;
    mode?: "dragAndDrop" | "select";
    position?: PositionConfig;
    search?: ColumnChooserSearchConfig;
    searchTimeout?: number;
    selection?: ColumnChooserSelectionConfig;
    sortOrder?: "asc" | "desc";
    title?: string;
    width?: number | string;
}>;
declare class ColumnChooser extends NestedOption<IColumnChooserProps> {
    static OptionName: string;
    static ExpectedChildren: {
        columnChooserSearch: {
            optionName: string;
            isCollectionItem: boolean;
        };
        columnChooserSelection: {
            optionName: string;
            isCollectionItem: boolean;
        };
        position: {
            optionName: string;
            isCollectionItem: boolean;
        };
        search: {
            optionName: string;
            isCollectionItem: boolean;
        };
        selection: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type IColumnChooserSearchProps = React.PropsWithChildren<{
    editorOptions?: any;
    enabled?: boolean;
    timeout?: number;
}>;
declare class ColumnChooserSearch extends NestedOption<IColumnChooserSearchProps> {
    static OptionName: string;
}
declare type IColumnChooserSelectionProps = React.PropsWithChildren<{
    allowSelectAll?: boolean;
    recursive?: boolean;
    selectByClick?: boolean;
}>;
declare class ColumnChooserSelection extends NestedOption<IColumnChooserSelectionProps> {
    static OptionName: string;
}
declare type IColumnFixingProps = React.PropsWithChildren<{
    enabled?: boolean;
    texts?: Record<string, any> | {
        fix?: string;
        leftPosition?: string;
        rightPosition?: string;
        unfix?: string;
    };
}>;
declare class ColumnFixing extends NestedOption<IColumnFixingProps> {
    static OptionName: string;
    static ExpectedChildren: {
        columnFixingTexts: {
            optionName: string;
            isCollectionItem: boolean;
        };
        texts: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type IColumnFixingTextsProps = React.PropsWithChildren<{
    fix?: string;
    leftPosition?: string;
    rightPosition?: string;
    unfix?: string;
}>;
declare class ColumnFixingTexts extends NestedOption<IColumnFixingTextsProps> {
    static OptionName: string;
}
declare type IColumnHeaderFilterProps = React.PropsWithChildren<{
    allowSearch?: boolean;
    allowSelectAll?: boolean;
    dataSource?: Array<any> | DataSourceOptions | ((options: {
        component: Record<string, any>;
        dataSource: DataSourceOptions | null;
    }) => void) | null | Store;
    groupInterval?: number | "day" | "hour" | "minute" | "month" | "quarter" | "second" | "year";
    height?: number | string;
    search?: ColumnHeaderFilterSearchConfig;
    searchMode?: "contains" | "startswith" | "equals";
    width?: number | string;
}>;
declare class ColumnHeaderFilter extends NestedOption<IColumnHeaderFilterProps> {
    static OptionName: string;
    static ExpectedChildren: {
        columnHeaderFilterSearch: {
            optionName: string;
            isCollectionItem: boolean;
        };
        search: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type IColumnHeaderFilterSearchProps = React.PropsWithChildren<{
    editorOptions?: any;
    enabled?: boolean;
    mode?: "contains" | "startswith" | "equals";
    searchExpr?: Array<(() => any) | string> | (() => any) | string;
    timeout?: number;
}>;
declare class ColumnHeaderFilterSearch extends NestedOption<IColumnHeaderFilterSearchProps> {
    static OptionName: string;
}
declare type IColumnLookupProps = React.PropsWithChildren<{
    allowClearing?: boolean;
    calculateCellValue?: ((rowData: any) => any);
    dataSource?: Array<any> | DataSourceOptions | ((options: {
        data: Record<string, any>;
        key: any;
    }) => Array<any> | Store | DataSourceOptions) | null | Store;
    displayExpr?: ((data: any) => string) | string;
    valueExpr?: string;
}>;
declare class ColumnLookup extends NestedOption<IColumnLookupProps> {
    static OptionName: string;
}
declare type ICompareRuleProps = React.PropsWithChildren<{
    comparisonTarget?: (() => any);
    comparisonType?: "!=" | "!==" | "<" | "<=" | "==" | "===" | ">" | ">=";
    ignoreEmptyValue?: boolean;
    message?: string;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
}>;
declare class CompareRule extends NestedOption<ICompareRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type ICursorOffsetProps = React.PropsWithChildren<{
    x?: number;
    y?: number;
}>;
declare class CursorOffset extends NestedOption<ICursorOffsetProps> {
    static OptionName: string;
}
declare type ICustomOperationProps = React.PropsWithChildren<{
    calculateFilterExpression?: ((filterValue: any, field: dxFilterBuilderField) => string | (() => any) | Array<any>);
    caption?: string;
    customizeText?: ((fieldInfo: {
        field: dxFilterBuilderField;
        value: string | number | Date;
        valueText: string;
    }) => string);
    dataTypes?: Array<"string" | "number" | "date" | "boolean" | "object" | "datetime">;
    editorTemplate?: ((conditionInfo: {
        field: dxFilterBuilderField;
        setValue: (() => void);
        value: string | number | Date;
    }, container: any) => string | any) | template;
    hasValue?: boolean;
    icon?: string;
    name?: string;
    editorRender?: (...params: any) => React.ReactNode;
    editorComponent?: React.ComponentType<any>;
    editorKeyFn?: (data: any) => string;
}>;
declare class CustomOperation extends NestedOption<ICustomOperationProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type ICustomRuleProps = React.PropsWithChildren<{
    ignoreEmptyValue?: boolean;
    message?: string;
    reevaluate?: boolean;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
    validationCallback?: ((options: {
        column: Record<string, any>;
        data: Record<string, any>;
        formItem: Record<string, any>;
        rule: Record<string, any>;
        validator: Record<string, any>;
        value: string | number;
    }) => boolean);
}>;
declare class CustomRule extends NestedOption<ICustomRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type IDataGridHeaderFilterProps = React.PropsWithChildren<{
    allowSearch?: boolean;
    allowSelectAll?: boolean;
    height?: number | string;
    search?: HeaderFilterSearchConfig;
    searchTimeout?: number;
    texts?: Record<string, any> | {
        cancel?: string;
        emptyValue?: string;
        ok?: string;
    };
    visible?: boolean;
    width?: number | string;
}>;
declare class DataGridHeaderFilter extends NestedOption<IDataGridHeaderFilterProps> {
    static OptionName: string;
    static ExpectedChildren: {
        dataGridHeaderFilterSearch: {
            optionName: string;
            isCollectionItem: boolean;
        };
        dataGridHeaderFilterTexts: {
            optionName: string;
            isCollectionItem: boolean;
        };
        search: {
            optionName: string;
            isCollectionItem: boolean;
        };
        texts: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type IDataGridHeaderFilterSearchProps = React.PropsWithChildren<{
    editorOptions?: any;
    enabled?: boolean;
    mode?: "contains" | "startswith" | "equals";
    timeout?: number;
}>;
declare class DataGridHeaderFilterSearch extends NestedOption<IDataGridHeaderFilterSearchProps> {
    static OptionName: string;
}
declare type IDataGridHeaderFilterTextsProps = React.PropsWithChildren<{
    cancel?: string;
    emptyValue?: string;
    ok?: string;
}>;
declare class DataGridHeaderFilterTexts extends NestedOption<IDataGridHeaderFilterTextsProps> {
    static OptionName: string;
}
declare type IDataGridSelectionProps = React.PropsWithChildren<{
    allowSelectAll?: boolean;
    deferred?: boolean;
    mode?: "single" | "multiple" | "none";
    selectAllMode?: "allPages" | "page";
    showCheckBoxesMode?: "always" | "none" | "onClick" | "onLongTap";
}>;
declare class DataGridSelection extends NestedOption<IDataGridSelectionProps> {
    static OptionName: string;
}
declare type IEditingProps = React.PropsWithChildren<{
    allowAdding?: boolean;
    allowDeleting?: boolean | ((options: {
        component: dxDataGrid;
        row: dxDataGridRowObject;
    }) => boolean);
    allowUpdating?: boolean | ((options: {
        component: dxDataGrid;
        row: dxDataGridRowObject;
    }) => boolean);
    changes?: Array<DataChange>;
    confirmDelete?: boolean;
    editColumnName?: string;
    editRowKey?: any;
    form?: dxFormOptions;
    mode?: "batch" | "cell" | "row" | "form" | "popup";
    newRowPosition?: "first" | "last" | "pageBottom" | "pageTop" | "viewportBottom" | "viewportTop";
    popup?: dxPopupOptions<any>;
    refreshMode?: "full" | "reshape" | "repaint";
    selectTextOnEditStart?: boolean;
    startEditAction?: "click" | "dblClick";
    texts?: any | {
        addRow?: string;
        cancelAllChanges?: string;
        cancelRowChanges?: string;
        confirmDeleteMessage?: string;
        confirmDeleteTitle?: string;
        deleteRow?: string;
        editRow?: string;
        saveAllChanges?: string;
        saveRowChanges?: string;
        undeleteRow?: string;
        validationCancelChanges?: string;
    };
    useIcons?: boolean;
    defaultChanges?: Array<DataChange>;
    onChangesChange?: (value: Array<DataChange>) => void;
    defaultEditColumnName?: string;
    onEditColumnNameChange?: (value: string) => void;
    defaultEditRowKey?: any;
    onEditRowKeyChange?: (value: any) => void;
}>;
declare class Editing extends NestedOption<IEditingProps> {
    static OptionName: string;
    static DefaultsProps: {
        defaultChanges: string;
        defaultEditColumnName: string;
        defaultEditRowKey: string;
    };
    static ExpectedChildren: {
        change: {
            optionName: string;
            isCollectionItem: boolean;
        };
        editingTexts: {
            optionName: string;
            isCollectionItem: boolean;
        };
        form: {
            optionName: string;
            isCollectionItem: boolean;
        };
        popup: {
            optionName: string;
            isCollectionItem: boolean;
        };
        texts: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type IEditingTextsProps = React.PropsWithChildren<{
    addRow?: string;
    cancelAllChanges?: string;
    cancelRowChanges?: string;
    confirmDeleteMessage?: string;
    confirmDeleteTitle?: string;
    deleteRow?: string;
    editRow?: string;
    saveAllChanges?: string;
    saveRowChanges?: string;
    undeleteRow?: string;
    validationCancelChanges?: string;
}>;
declare class EditingTexts extends NestedOption<IEditingTextsProps> {
    static OptionName: string;
}
declare type IEmailRuleProps = React.PropsWithChildren<{
    ignoreEmptyValue?: boolean;
    message?: string;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
}>;
declare class EmailRule extends NestedOption<IEmailRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type IExportProps = React.PropsWithChildren<{
    allowExportSelectedData?: boolean;
    enabled?: boolean;
    formats?: Array<"pdf" | "xlsx" | string>;
    texts?: Record<string, any> | {
        exportAll?: string;
        exportSelectedRows?: string;
        exportTo?: string;
    };
}>;
declare class Export extends NestedOption<IExportProps> {
    static OptionName: string;
    static ExpectedChildren: {
        exportTexts: {
            optionName: string;
            isCollectionItem: boolean;
        };
        texts: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type IExportTextsProps = React.PropsWithChildren<{
    exportAll?: string;
    exportSelectedRows?: string;
    exportTo?: string;
}>;
declare class ExportTexts extends NestedOption<IExportTextsProps> {
    static OptionName: string;
}
declare type IFieldProps = React.PropsWithChildren<{
    calculateFilterExpression?: ((filterValue: any, selectedFilterOperation: string) => string | (() => any) | Array<any>);
    caption?: string;
    customizeText?: ((fieldInfo: {
        value: string | number | Date;
        valueText: string;
    }) => string);
    dataField?: string;
    dataType?: "string" | "number" | "date" | "boolean" | "object" | "datetime";
    editorOptions?: any;
    editorTemplate?: ((conditionInfo: {
        field: dxFilterBuilderField;
        filterOperation: string;
        setValue: (() => void);
        value: string | number | Date;
    }, container: any) => string | any) | template;
    falseText?: string;
    filterOperations?: Array<"=" | "<>" | "<" | "<=" | ">" | ">=" | "contains" | "endswith" | "isblank" | "isnotblank" | "notcontains" | "startswith" | "between" | string>;
    format?: LocalizationTypes.Format;
    lookup?: Record<string, any> | {
        allowClearing?: boolean;
        dataSource?: Array<any> | DataSourceOptions | Store;
        displayExpr?: ((data: any) => string) | string;
        valueExpr?: ((data: any) => string | number | boolean) | string;
    };
    name?: string;
    trueText?: string;
    editorRender?: (...params: any) => React.ReactNode;
    editorComponent?: React.ComponentType<any>;
    editorKeyFn?: (data: any) => string;
}>;
declare class Field extends NestedOption<IFieldProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static ExpectedChildren: {
        fieldLookup: {
            optionName: string;
            isCollectionItem: boolean;
        };
        format: {
            optionName: string;
            isCollectionItem: boolean;
        };
        lookup: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type IFieldLookupProps = React.PropsWithChildren<{
    allowClearing?: boolean;
    dataSource?: Array<any> | DataSourceOptions | Store;
    displayExpr?: ((data: any) => string) | string;
    valueExpr?: ((data: any) => string | number | boolean) | string;
}>;
declare class FieldLookup extends NestedOption<IFieldLookupProps> {
    static OptionName: string;
}
declare type IFilterBuilderProps = React.PropsWithChildren<{
    accessKey?: string;
    activeStateEnabled?: boolean;
    allowHierarchicalFields?: boolean;
    bindingOptions?: Record<string, any>;
    customOperations?: Array<dxFilterBuilderCustomOperation>;
    disabled?: boolean;
    elementAttr?: Record<string, any>;
    fields?: Array<dxFilterBuilderField>;
    filterOperationDescriptions?: Record<string, any> | {
        between?: string;
        contains?: string;
        endsWith?: string;
        equal?: string;
        greaterThan?: string;
        greaterThanOrEqual?: string;
        isBlank?: string;
        isNotBlank?: string;
        lessThan?: string;
        lessThanOrEqual?: string;
        notContains?: string;
        notEqual?: string;
        startsWith?: string;
    };
    focusStateEnabled?: boolean;
    groupOperationDescriptions?: Record<string, any> | {
        and?: string;
        notAnd?: string;
        notOr?: string;
        or?: string;
    };
    groupOperations?: Array<"and" | "or" | "notAnd" | "notOr">;
    height?: (() => number | string) | number | string;
    hint?: string;
    hoverStateEnabled?: boolean;
    maxGroupLevel?: number;
    onContentReady?: ((e: FilterBuilderContentReadyEvent) => void);
    onDisposing?: ((e: FilterBuilderDisposingEvent) => void);
    onEditorPrepared?: ((e: FilterBuilderEditorPreparedEvent) => void);
    onEditorPreparing?: ((e: FilterBuilderEditorPreparingEvent) => void);
    onInitialized?: ((e: FilterBuilderInitializedEvent) => void);
    onOptionChanged?: ((e: OptionChangedEvent) => void);
    onValueChanged?: ((e: ValueChangedEvent) => void);
    rtlEnabled?: boolean;
    tabIndex?: number;
    value?: Array<any> | (() => any) | string;
    visible?: boolean;
    width?: (() => number | string) | number | string;
    defaultValue?: Array<any> | (() => any) | string;
    onValueChange?: (value: Array<any> | (() => any) | string) => void;
}>;
declare class FilterBuilder extends NestedOption<IFilterBuilderProps> {
    static OptionName: string;
    static DefaultsProps: {
        defaultValue: string;
    };
    static ExpectedChildren: {
        customOperation: {
            optionName: string;
            isCollectionItem: boolean;
        };
        field: {
            optionName: string;
            isCollectionItem: boolean;
        };
        filterOperationDescriptions: {
            optionName: string;
            isCollectionItem: boolean;
        };
        groupOperationDescriptions: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type IFilterBuilderPopupProps = React.PropsWithChildren<{
    accessKey?: string;
    animation?: Record<string, any> | {
        hide?: AnimationConfig;
        show?: AnimationConfig;
    };
    bindingOptions?: Record<string, any>;
    closeOnOutsideClick?: boolean | ((event: event) => boolean);
    container?: any | string;
    contentTemplate?: ((contentElement: any) => string | any) | template;
    copyRootClassesToWrapper?: boolean;
    deferRendering?: boolean;
    disabled?: boolean;
    dragAndResizeArea?: any | string;
    dragEnabled?: boolean;
    dragOutsideBoundary?: boolean;
    elementAttr?: any;
    enableBodyScroll?: boolean;
    focusStateEnabled?: boolean;
    fullScreen?: boolean;
    height?: (() => number | string) | number | string;
    hideOnOutsideClick?: boolean | ((event: event) => boolean);
    hideOnParentScroll?: boolean;
    hint?: string;
    hoverStateEnabled?: boolean;
    maxHeight?: (() => number | string) | number | string;
    maxWidth?: (() => number | string) | number | string;
    minHeight?: (() => number | string) | number | string;
    minWidth?: (() => number | string) | number | string;
    onContentReady?: ((e: EventInfo<any>) => void);
    onDisposing?: ((e: EventInfo<any>) => void);
    onHidden?: ((e: EventInfo<any>) => void);
    onHiding?: ((e: {
        cancel: boolean | any;
        component: dxOverlay<any>;
        element: any;
        model: any;
    }) => void);
    onInitialized?: ((e: {
        component: Component<any>;
        element: any;
    }) => void);
    onOptionChanged?: ((e: {
        component: DOMComponent;
        element: any;
        fullName: string;
        model: any;
        name: string;
        previousValue: any;
        value: any;
    }) => void);
    onResize?: ((e: {
        component: dxPopup;
        element: any;
        event: event;
        height: number;
        model: any;
        width: number;
    }) => void);
    onResizeEnd?: ((e: {
        component: dxPopup;
        element: any;
        event: event;
        height: number;
        model: any;
        width: number;
    }) => void);
    onResizeStart?: ((e: {
        component: dxPopup;
        element: any;
        event: event;
        height: number;
        model: any;
        width: number;
    }) => void);
    onShowing?: ((e: {
        cancel: boolean | any;
        component: dxOverlay<any>;
        element: any;
        model: any;
    }) => void);
    onShown?: ((e: EventInfo<any>) => void);
    onTitleRendered?: ((e: {
        component: dxPopup;
        element: any;
        model: any;
        titleElement: any;
    }) => void);
    position?: (() => void) | PositionConfig | "bottom" | "center" | "left" | "left bottom" | "left top" | "right" | "right bottom" | "right top" | "top";
    resizeEnabled?: boolean;
    restorePosition?: boolean;
    rtlEnabled?: boolean;
    shading?: boolean;
    shadingColor?: string;
    showCloseButton?: boolean;
    showTitle?: boolean;
    tabIndex?: number;
    title?: string;
    titleTemplate?: ((titleElement: any) => string | any) | template;
    toolbarItems?: Array<dxPopupToolbarItem>;
    visible?: boolean;
    width?: (() => number | string) | number | string;
    wrapperAttr?: any;
    defaultHeight?: (() => number | string) | number | string;
    onHeightChange?: (value: (() => number | string) | number | string) => void;
    defaultPosition?: (() => void) | PositionConfig | "bottom" | "center" | "left" | "left bottom" | "left top" | "right" | "right bottom" | "right top" | "top";
    onPositionChange?: (value: (() => void) | PositionConfig | "bottom" | "center" | "left" | "left bottom" | "left top" | "right" | "right bottom" | "right top" | "top") => void;
    defaultVisible?: boolean;
    onVisibleChange?: (value: boolean) => void;
    defaultWidth?: (() => number | string) | number | string;
    onWidthChange?: (value: (() => number | string) | number | string) => void;
    contentRender?: (...params: any) => React.ReactNode;
    contentComponent?: React.ComponentType<any>;
    contentKeyFn?: (data: any) => string;
    titleRender?: (...params: any) => React.ReactNode;
    titleComponent?: React.ComponentType<any>;
    titleKeyFn?: (data: any) => string;
}>;
declare class FilterBuilderPopup extends NestedOption<IFilterBuilderPopupProps> {
    static OptionName: string;
    static DefaultsProps: {
        defaultHeight: string;
        defaultPosition: string;
        defaultVisible: string;
        defaultWidth: string;
    };
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type IFilterOperationDescriptionsProps = React.PropsWithChildren<{
    between?: string;
    contains?: string;
    endsWith?: string;
    equal?: string;
    greaterThan?: string;
    greaterThanOrEqual?: string;
    isBlank?: string;
    isNotBlank?: string;
    lessThan?: string;
    lessThanOrEqual?: string;
    notContains?: string;
    notEqual?: string;
    startsWith?: string;
}>;
declare class FilterOperationDescriptions extends NestedOption<IFilterOperationDescriptionsProps> {
    static OptionName: string;
}
declare type IFilterPanelProps = React.PropsWithChildren<{
    customizeText?: ((e: {
        component: GridBase;
        filterValue: Record<string, any>;
        text: string;
    }) => string);
    filterEnabled?: boolean;
    texts?: Record<string, any> | {
        clearFilter?: string;
        createFilter?: string;
        filterEnabledHint?: string;
    };
    visible?: boolean;
    defaultFilterEnabled?: boolean;
    onFilterEnabledChange?: (value: boolean) => void;
}>;
declare class FilterPanel extends NestedOption<IFilterPanelProps> {
    static OptionName: string;
    static DefaultsProps: {
        defaultFilterEnabled: string;
    };
    static ExpectedChildren: {
        filterPanelTexts: {
            optionName: string;
            isCollectionItem: boolean;
        };
        texts: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type IFilterPanelTextsProps = React.PropsWithChildren<{
    clearFilter?: string;
    createFilter?: string;
    filterEnabledHint?: string;
}>;
declare class FilterPanelTexts extends NestedOption<IFilterPanelTextsProps> {
    static OptionName: string;
}
declare type IFilterRowProps = React.PropsWithChildren<{
    applyFilter?: "auto" | "onClick";
    applyFilterText?: string;
    betweenEndText?: string;
    betweenStartText?: string;
    operationDescriptions?: Record<string, any> | {
        between?: string;
        contains?: string;
        endsWith?: string;
        equal?: string;
        greaterThan?: string;
        greaterThanOrEqual?: string;
        lessThan?: string;
        lessThanOrEqual?: string;
        notContains?: string;
        notEqual?: string;
        startsWith?: string;
    };
    resetOperationText?: string;
    showAllText?: string;
    showOperationChooser?: boolean;
    visible?: boolean;
}>;
declare class FilterRow extends NestedOption<IFilterRowProps> {
    static OptionName: string;
    static ExpectedChildren: {
        operationDescriptions: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type IFormProps = React.PropsWithChildren<{
    accessKey?: string;
    activeStateEnabled?: boolean;
    alignItemLabels?: boolean;
    alignItemLabelsInAllGroups?: boolean;
    bindingOptions?: Record<string, any>;
    colCount?: number | "auto";
    colCountByScreen?: Record<string, any> | {
        lg?: number;
        md?: number;
        sm?: number;
        xs?: number;
    };
    customizeItem?: ((item: dxFormSimpleItem | dxFormGroupItem | dxFormTabbedItem | dxFormEmptyItem | dxFormButtonItem) => void);
    disabled?: boolean;
    elementAttr?: Record<string, any>;
    focusStateEnabled?: boolean;
    formData?: any;
    height?: (() => number | string) | number | string;
    hint?: string;
    hoverStateEnabled?: boolean;
    isDirty?: boolean;
    items?: Array<dxFormButtonItem | dxFormEmptyItem | dxFormGroupItem | dxFormSimpleItem | dxFormTabbedItem>;
    labelLocation?: "left" | "right" | "top";
    labelMode?: "static" | "floating" | "hidden" | "outside";
    minColWidth?: number;
    onContentReady?: ((e: FormContentReadyEvent) => void);
    onDisposing?: ((e: FormDisposingEvent) => void);
    onEditorEnterKey?: ((e: EditorEnterKeyEvent) => void);
    onFieldDataChanged?: ((e: FieldDataChangedEvent) => void);
    onInitialized?: ((e: FormInitializedEvent) => void);
    onOptionChanged?: ((e: FormOptionChangedEvent) => void);
    optionalMark?: string;
    readOnly?: boolean;
    requiredMark?: string;
    requiredMessage?: string;
    rtlEnabled?: boolean;
    screenByWidth?: (() => void);
    scrollingEnabled?: boolean;
    showColonAfterLabel?: boolean;
    showOptionalMark?: boolean;
    showRequiredMark?: boolean;
    showValidationSummary?: boolean;
    tabIndex?: number;
    validationGroup?: string;
    visible?: boolean;
    width?: (() => number | string) | number | string;
    defaultFormData?: any;
    onFormDataChange?: (value: any) => void;
}>;
declare class Form extends NestedOption<IFormProps> {
    static OptionName: string;
    static DefaultsProps: {
        defaultFormData: string;
    };
    static ExpectedChildren: {
        colCountByScreen: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type IFormatProps = React.PropsWithChildren<{
    currency?: string;
    formatter?: ((value: number | Date) => string);
    parser?: ((value: string) => number | Date);
    precision?: number;
    type?: "billions" | "currency" | "day" | "decimal" | "exponential" | "fixedPoint" | "largeNumber" | "longDate" | "longTime" | "millions" | "millisecond" | "month" | "monthAndDay" | "monthAndYear" | "percent" | "quarter" | "quarterAndYear" | "shortDate" | "shortTime" | "thousands" | "trillions" | "year" | "dayOfWeek" | "hour" | "longDateLongTime" | "minute" | "second" | "shortDateShortTime";
    useCurrencyAccountingStyle?: boolean;
}>;
declare class Format extends NestedOption<IFormatProps> {
    static OptionName: string;
}
declare type IFormItemProps = React.PropsWithChildren<{
    colSpan?: number;
    cssClass?: string;
    dataField?: string;
    editorOptions?: any;
    editorType?: "dxAutocomplete" | "dxCalendar" | "dxCheckBox" | "dxColorBox" | "dxDateBox" | "dxDateRangeBox" | "dxDropDownBox" | "dxHtmlEditor" | "dxLookup" | "dxNumberBox" | "dxRadioGroup" | "dxRangeSlider" | "dxSelectBox" | "dxSlider" | "dxSwitch" | "dxTagBox" | "dxTextArea" | "dxTextBox";
    helpText?: string;
    isRequired?: boolean;
    itemType?: "empty" | "group" | "simple" | "tabbed" | "button";
    label?: Record<string, any> | {
        alignment?: "center" | "left" | "right";
        location?: "left" | "right" | "top";
        showColon?: boolean;
        template?: ((itemData: {
            component: dxForm;
            dataField: string;
            editorOptions: any;
            editorType: string;
            name: string;
            text: string;
        }, itemElement: any) => string | any) | template;
        text?: string;
        visible?: boolean;
    };
    name?: string;
    template?: ((data: {
        component: dxForm;
        dataField: string;
        editorOptions: Record<string, any>;
        editorType: string;
        name: string;
    }, itemElement: any) => string | any) | template;
    validationRules?: Array<CommonTypes.ValidationRule>;
    visible?: boolean;
    visibleIndex?: number;
    render?: (...params: any) => React.ReactNode;
    component?: React.ComponentType<any>;
    keyFn?: (data: any) => string;
}>;
declare class FormItem extends NestedOption<IFormItemProps> {
    static OptionName: string;
    static ExpectedChildren: {
        AsyncRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        CompareRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        CustomRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        EmailRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        label: {
            optionName: string;
            isCollectionItem: boolean;
        };
        NumericRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        PatternRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        RangeRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        RequiredRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        StringLengthRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
        validationRule: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type IFromProps = React.PropsWithChildren<{
    left?: number;
    opacity?: number;
    position?: PositionConfig;
    scale?: number;
    top?: number;
}>;
declare class From extends NestedOption<IFromProps> {
    static OptionName: string;
    static ExpectedChildren: {
        position: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type IGroupingProps = React.PropsWithChildren<{
    allowCollapsing?: boolean;
    autoExpandAll?: boolean;
    contextMenuEnabled?: boolean;
    expandMode?: "buttonClick" | "rowClick";
    texts?: Record<string, any> | {
        groupByThisColumn?: string;
        groupContinuedMessage?: string;
        groupContinuesMessage?: string;
        ungroup?: string;
        ungroupAll?: string;
    };
}>;
declare class Grouping extends NestedOption<IGroupingProps> {
    static OptionName: string;
    static ExpectedChildren: {
        groupingTexts: {
            optionName: string;
            isCollectionItem: boolean;
        };
        texts: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type IGroupingTextsProps = React.PropsWithChildren<{
    groupByThisColumn?: string;
    groupContinuedMessage?: string;
    groupContinuesMessage?: string;
    ungroup?: string;
    ungroupAll?: string;
}>;
declare class GroupingTexts extends NestedOption<IGroupingTextsProps> {
    static OptionName: string;
}
declare type IGroupItemProps = React.PropsWithChildren<{
    alignByColumn?: boolean;
    column?: string;
    customizeText?: ((itemInfo: {
        value: string | number | Date;
        valueText: string;
    }) => string);
    displayFormat?: string;
    name?: string;
    showInColumn?: string;
    showInGroupFooter?: boolean;
    skipEmptyValues?: boolean;
    summaryType?: "avg" | "count" | "custom" | "max" | "min" | "sum";
    valueFormat?: LocalizationTypes.Format;
}>;
declare class GroupItem extends NestedOption<IGroupItemProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static ExpectedChildren: {
        valueFormat: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type IGroupOperationDescriptionsProps = React.PropsWithChildren<{
    and?: string;
    notAnd?: string;
    notOr?: string;
    or?: string;
}>;
declare class GroupOperationDescriptions extends NestedOption<IGroupOperationDescriptionsProps> {
    static OptionName: string;
}
declare type IGroupPanelProps = React.PropsWithChildren<{
    allowColumnDragging?: boolean;
    emptyPanelText?: string;
    visible?: boolean | "auto";
    defaultVisible?: boolean | "auto";
    onVisibleChange?: (value: boolean | "auto") => void;
}>;
declare class GroupPanel extends NestedOption<IGroupPanelProps> {
    static OptionName: string;
    static DefaultsProps: {
        defaultVisible: string;
    };
}
declare type IHeaderFilterProps = React.PropsWithChildren<{
    allowSearch?: boolean;
    allowSelectAll?: boolean;
    dataSource?: Array<any> | DataSourceOptions | ((options: {
        component: Record<string, any>;
        dataSource: DataSourceOptions | null;
    }) => void) | null | Store;
    groupInterval?: number | "day" | "hour" | "minute" | "month" | "quarter" | "second" | "year";
    height?: number | string;
    search?: ColumnHeaderFilterSearchConfig | HeaderFilterSearchConfig;
    searchMode?: "contains" | "startswith" | "equals";
    width?: number | string;
    searchTimeout?: number;
    texts?: Record<string, any> | {
        cancel?: string;
        emptyValue?: string;
        ok?: string;
    };
    visible?: boolean;
}>;
declare class HeaderFilter extends NestedOption<IHeaderFilterProps> {
    static OptionName: string;
}
declare type IHideProps = React.PropsWithChildren<{
    complete?: (($element: any, config: AnimationConfig) => void);
    delay?: number;
    direction?: "bottom" | "left" | "right" | "top";
    duration?: number;
    easing?: string;
    from?: AnimationState;
    staggerDelay?: number;
    start?: (($element: any, config: AnimationConfig) => void);
    to?: AnimationState;
    type?: "css" | "fade" | "fadeIn" | "fadeOut" | "pop" | "slide" | "slideIn" | "slideOut";
}>;
declare class Hide extends NestedOption<IHideProps> {
    static OptionName: string;
    static ExpectedChildren: {
        from: {
            optionName: string;
            isCollectionItem: boolean;
        };
        to: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type IItemProps = React.PropsWithChildren<{
    cssClass?: string;
    disabled?: boolean;
    html?: string;
    locateInMenu?: "always" | "auto" | "never";
    location?: "after" | "before" | "center";
    menuItemTemplate?: (() => string | any) | template;
    name?: "addRowButton" | "applyFilterButton" | "columnChooserButton" | "exportButton" | "groupPanel" | "revertButton" | "saveButton" | "searchPanel";
    options?: any;
    showText?: "always" | "inMenu";
    template?: ((itemData: CollectionWidgetItem, itemIndex: number, itemElement: any) => string | any) | template;
    text?: string;
    visible?: boolean;
    widget?: "dxAutocomplete" | "dxButton" | "dxButtonGroup" | "dxCheckBox" | "dxDateBox" | "dxDropDownButton" | "dxMenu" | "dxSelectBox" | "dxSwitch" | "dxTabs" | "dxTextBox";
    menuItemRender?: (...params: any) => React.ReactNode;
    menuItemComponent?: React.ComponentType<any>;
    menuItemKeyFn?: (data: any) => string;
    render?: (...params: any) => React.ReactNode;
    component?: React.ComponentType<any>;
    keyFn?: (data: any) => string;
}>;
declare class Item extends NestedOption<IItemProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type IKeyboardNavigationProps = React.PropsWithChildren<{
    editOnKeyPress?: boolean;
    enabled?: boolean;
    enterKeyAction?: "startEdit" | "moveFocus";
    enterKeyDirection?: "none" | "column" | "row";
}>;
declare class KeyboardNavigation extends NestedOption<IKeyboardNavigationProps> {
    static OptionName: string;
}
declare type ILabelProps = React.PropsWithChildren<{
    alignment?: "center" | "left" | "right";
    location?: "left" | "right" | "top";
    showColon?: boolean;
    template?: ((itemData: {
        component: dxForm;
        dataField: string;
        editorOptions: any;
        editorType: string;
        name: string;
        text: string;
    }, itemElement: any) => string | any) | template;
    text?: string;
    visible?: boolean;
    render?: (...params: any) => React.ReactNode;
    component?: React.ComponentType<any>;
    keyFn?: (data: any) => string;
}>;
declare class Label extends NestedOption<ILabelProps> {
    static OptionName: string;
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type ILoadPanelProps = React.PropsWithChildren<{
    enabled?: boolean | "auto";
    height?: number | string;
    indicatorSrc?: string;
    shading?: boolean;
    shadingColor?: string;
    showIndicator?: boolean;
    showPane?: boolean;
    text?: string;
    width?: number | string;
}>;
declare class LoadPanel extends NestedOption<ILoadPanelProps> {
    static OptionName: string;
}
declare type ILookupProps = React.PropsWithChildren<{
    allowClearing?: boolean;
    calculateCellValue?: ((rowData: any) => any);
    dataSource?: Array<any> | DataSourceOptions | ((options: {
        data: Record<string, any>;
        key: any;
    }) => Array<any> | Store | DataSourceOptions) | null | Store;
    displayExpr?: ((data: any) => string) | string;
    valueExpr?: string | ((data: any) => string | number | boolean);
}>;
declare class Lookup extends NestedOption<ILookupProps> {
    static OptionName: string;
}
declare type IMasterDetailProps = React.PropsWithChildren<{
    autoExpandAll?: boolean;
    enabled?: boolean;
    template?: ((detailElement: any, detailInfo: {
        data: Record<string, any>;
        key: any;
        watch: (() => void);
    }) => any) | template;
    render?: (...params: any) => React.ReactNode;
    component?: React.ComponentType<any>;
    keyFn?: (data: any) => string;
}>;
declare class MasterDetail extends NestedOption<IMasterDetailProps> {
    static OptionName: string;
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type IMyProps = React.PropsWithChildren<{
    x?: "center" | "left" | "right";
    y?: "bottom" | "center" | "top";
}>;
declare class My extends NestedOption<IMyProps> {
    static OptionName: string;
}
declare type INumericRuleProps = React.PropsWithChildren<{
    ignoreEmptyValue?: boolean;
    message?: string;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
}>;
declare class NumericRule extends NestedOption<INumericRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type IOffsetProps = React.PropsWithChildren<{
    x?: number;
    y?: number;
}>;
declare class Offset extends NestedOption<IOffsetProps> {
    static OptionName: string;
}
declare type IOperationDescriptionsProps = React.PropsWithChildren<{
    between?: string;
    contains?: string;
    endsWith?: string;
    equal?: string;
    greaterThan?: string;
    greaterThanOrEqual?: string;
    lessThan?: string;
    lessThanOrEqual?: string;
    notContains?: string;
    notEqual?: string;
    startsWith?: string;
}>;
declare class OperationDescriptions extends NestedOption<IOperationDescriptionsProps> {
    static OptionName: string;
}
declare type IPagerProps = React.PropsWithChildren<{
    allowedPageSizes?: Array<number | "all" | "auto"> | "auto";
    displayMode?: "adaptive" | "compact" | "full";
    infoText?: string;
    label?: string;
    showInfo?: boolean;
    showNavigationButtons?: boolean;
    showPageSizeSelector?: boolean;
    visible?: boolean | "auto";
}>;
declare class Pager extends NestedOption<IPagerProps> {
    static OptionName: string;
}
declare type IPagingProps = React.PropsWithChildren<{
    enabled?: boolean;
    pageIndex?: number;
    pageSize?: number;
    defaultPageIndex?: number;
    onPageIndexChange?: (value: number) => void;
    defaultPageSize?: number;
    onPageSizeChange?: (value: number) => void;
}>;
declare class Paging extends NestedOption<IPagingProps> {
    static OptionName: string;
    static DefaultsProps: {
        defaultPageIndex: string;
        defaultPageSize: string;
    };
}
declare type IPatternRuleProps = React.PropsWithChildren<{
    ignoreEmptyValue?: boolean;
    message?: string;
    pattern?: RegExp | string;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
}>;
declare class PatternRule extends NestedOption<IPatternRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type IPopupProps = React.PropsWithChildren<{
    accessKey?: string;
    animation?: Record<string, any> | {
        hide?: AnimationConfig;
        show?: AnimationConfig;
    };
    bindingOptions?: Record<string, any>;
    closeOnOutsideClick?: boolean | ((event: event) => boolean);
    container?: any | string;
    contentTemplate?: ((contentElement: any) => string | any) | template;
    copyRootClassesToWrapper?: boolean;
    deferRendering?: boolean;
    disabled?: boolean;
    dragAndResizeArea?: any | string;
    dragEnabled?: boolean;
    dragOutsideBoundary?: boolean;
    elementAttr?: any;
    enableBodyScroll?: boolean;
    focusStateEnabled?: boolean;
    fullScreen?: boolean;
    height?: (() => number | string) | number | string;
    hideOnOutsideClick?: boolean | ((event: event) => boolean);
    hideOnParentScroll?: boolean;
    hint?: string;
    hoverStateEnabled?: boolean;
    maxHeight?: (() => number | string) | number | string;
    maxWidth?: (() => number | string) | number | string;
    minHeight?: (() => number | string) | number | string;
    minWidth?: (() => number | string) | number | string;
    onContentReady?: ((e: EventInfo<any>) => void);
    onDisposing?: ((e: EventInfo<any>) => void);
    onHidden?: ((e: EventInfo<any>) => void);
    onHiding?: ((e: {
        cancel: boolean | any;
        component: dxOverlay<any>;
        element: any;
        model: any;
    }) => void);
    onInitialized?: ((e: {
        component: Component<any>;
        element: any;
    }) => void);
    onOptionChanged?: ((e: {
        component: DOMComponent;
        element: any;
        fullName: string;
        model: any;
        name: string;
        previousValue: any;
        value: any;
    }) => void);
    onResize?: ((e: {
        component: dxPopup;
        element: any;
        event: event;
        height: number;
        model: any;
        width: number;
    }) => void);
    onResizeEnd?: ((e: {
        component: dxPopup;
        element: any;
        event: event;
        height: number;
        model: any;
        width: number;
    }) => void);
    onResizeStart?: ((e: {
        component: dxPopup;
        element: any;
        event: event;
        height: number;
        model: any;
        width: number;
    }) => void);
    onShowing?: ((e: {
        cancel: boolean | any;
        component: dxOverlay<any>;
        element: any;
        model: any;
    }) => void);
    onShown?: ((e: EventInfo<any>) => void);
    onTitleRendered?: ((e: {
        component: dxPopup;
        element: any;
        model: any;
        titleElement: any;
    }) => void);
    position?: (() => void) | PositionConfig | "bottom" | "center" | "left" | "left bottom" | "left top" | "right" | "right bottom" | "right top" | "top";
    resizeEnabled?: boolean;
    restorePosition?: boolean;
    rtlEnabled?: boolean;
    shading?: boolean;
    shadingColor?: string;
    showCloseButton?: boolean;
    showTitle?: boolean;
    tabIndex?: number;
    title?: string;
    titleTemplate?: ((titleElement: any) => string | any) | template;
    toolbarItems?: Array<dxPopupToolbarItem>;
    visible?: boolean;
    width?: (() => number | string) | number | string;
    wrapperAttr?: any;
    defaultHeight?: (() => number | string) | number | string;
    onHeightChange?: (value: (() => number | string) | number | string) => void;
    defaultPosition?: (() => void) | PositionConfig | "bottom" | "center" | "left" | "left bottom" | "left top" | "right" | "right bottom" | "right top" | "top";
    onPositionChange?: (value: (() => void) | PositionConfig | "bottom" | "center" | "left" | "left bottom" | "left top" | "right" | "right bottom" | "right top" | "top") => void;
    defaultVisible?: boolean;
    onVisibleChange?: (value: boolean) => void;
    defaultWidth?: (() => number | string) | number | string;
    onWidthChange?: (value: (() => number | string) | number | string) => void;
    contentRender?: (...params: any) => React.ReactNode;
    contentComponent?: React.ComponentType<any>;
    contentKeyFn?: (data: any) => string;
    titleRender?: (...params: any) => React.ReactNode;
    titleComponent?: React.ComponentType<any>;
    titleKeyFn?: (data: any) => string;
}>;
declare class Popup extends NestedOption<IPopupProps> {
    static OptionName: string;
    static DefaultsProps: {
        defaultHeight: string;
        defaultPosition: string;
        defaultVisible: string;
        defaultWidth: string;
    };
    static ExpectedChildren: {
        animation: {
            optionName: string;
            isCollectionItem: boolean;
        };
        position: {
            optionName: string;
            isCollectionItem: boolean;
        };
        toolbarItem: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type IPositionProps = React.PropsWithChildren<{
    at?: Record<string, any> | "bottom" | "center" | "left" | "left bottom" | "left top" | "right" | "right bottom" | "right top" | "top" | {
        x?: "center" | "left" | "right";
        y?: "bottom" | "center" | "top";
    };
    boundary?: any | string;
    boundaryOffset?: Record<string, any> | string | {
        x?: number;
        y?: number;
    };
    collision?: Record<string, any> | "fit" | "fit flip" | "fit flipfit" | "fit none" | "flip" | "flip fit" | "flip none" | "flipfit" | "flipfit fit" | "flipfit none" | "none" | "none fit" | "none flip" | "none flipfit" | {
        x?: "fit" | "flip" | "flipfit" | "none";
        y?: "fit" | "flip" | "flipfit" | "none";
    };
    my?: Record<string, any> | "bottom" | "center" | "left" | "left bottom" | "left top" | "right" | "right bottom" | "right top" | "top" | {
        x?: "center" | "left" | "right";
        y?: "bottom" | "center" | "top";
    };
    of?: any | string;
    offset?: Record<string, any> | string | {
        x?: number;
        y?: number;
    };
}>;
declare class Position extends NestedOption<IPositionProps> {
    static OptionName: string;
}
declare type IRangeRuleProps = React.PropsWithChildren<{
    ignoreEmptyValue?: boolean;
    max?: Date | number | string;
    message?: string;
    min?: Date | number | string;
    reevaluate?: boolean;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
}>;
declare class RangeRule extends NestedOption<IRangeRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type IRemoteOperationsProps = React.PropsWithChildren<{
    filtering?: boolean;
    grouping?: boolean;
    groupPaging?: boolean;
    paging?: boolean;
    sorting?: boolean;
    summary?: boolean;
}>;
declare class RemoteOperations extends NestedOption<IRemoteOperationsProps> {
    static OptionName: string;
}
declare type IRequiredRuleProps = React.PropsWithChildren<{
    message?: string;
    trim?: boolean;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
}>;
declare class RequiredRule extends NestedOption<IRequiredRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type IRowDraggingProps = React.PropsWithChildren<{
    allowDropInsideItem?: boolean;
    allowReordering?: boolean;
    autoScroll?: boolean;
    boundary?: any | string;
    container?: any | string;
    cursorOffset?: Record<string, any> | string | {
        x?: number;
        y?: number;
    };
    data?: any;
    dragDirection?: "both" | "horizontal" | "vertical";
    dragTemplate?: ((dragInfo: {
        itemData: any;
        itemElement: any;
    }, containerElement: any) => string | any) | template;
    dropFeedbackMode?: "push" | "indicate";
    filter?: string;
    group?: string;
    handle?: string;
    onAdd?: ((e: {
        component: GridBase;
        dropInsideItem: boolean;
        event: event;
        fromComponent: dxSortable | dxDraggable;
        fromData: any;
        fromIndex: number;
        itemData: any;
        itemElement: any;
        toComponent: dxSortable | dxDraggable;
        toData: any;
        toIndex: number;
    }) => void);
    onDragChange?: ((e: {
        cancel: boolean;
        component: GridBase;
        dropInsideItem: boolean;
        event: event;
        fromComponent: dxSortable | dxDraggable;
        fromData: any;
        fromIndex: number;
        itemData: any;
        itemElement: any;
        toComponent: dxSortable | dxDraggable;
        toData: any;
        toIndex: number;
    }) => void);
    onDragEnd?: ((e: {
        cancel: boolean;
        component: GridBase;
        dropInsideItem: boolean;
        event: event;
        fromComponent: dxSortable | dxDraggable;
        fromData: any;
        fromIndex: number;
        itemData: any;
        itemElement: any;
        toComponent: dxSortable | dxDraggable;
        toData: any;
        toIndex: number;
    }) => void);
    onDragMove?: ((e: {
        cancel: boolean;
        component: GridBase;
        dropInsideItem: boolean;
        event: event;
        fromComponent: dxSortable | dxDraggable;
        fromData: any;
        fromIndex: number;
        itemData: any;
        itemElement: any;
        toComponent: dxSortable | dxDraggable;
        toData: any;
        toIndex: number;
    }) => void);
    onDragStart?: ((e: {
        cancel: boolean;
        component: GridBase;
        event: event;
        fromData: any;
        fromIndex: number;
        itemData: any;
        itemElement: any;
    }) => void);
    onRemove?: ((e: {
        component: GridBase;
        event: event;
        fromComponent: dxSortable | dxDraggable;
        fromData: any;
        fromIndex: number;
        itemData: any;
        itemElement: any;
        toComponent: dxSortable | dxDraggable;
        toData: any;
        toIndex: number;
    }) => void);
    onReorder?: ((e: {
        component: GridBase;
        dropInsideItem: boolean;
        event: event;
        fromComponent: dxSortable | dxDraggable;
        fromData: any;
        fromIndex: number;
        itemData: any;
        itemElement: any;
        promise: any;
        toComponent: dxSortable | dxDraggable;
        toData: any;
        toIndex: number;
    }) => void);
    scrollSensitivity?: number;
    scrollSpeed?: number;
    showDragIcons?: boolean;
    dragRender?: (...params: any) => React.ReactNode;
    dragComponent?: React.ComponentType<any>;
    dragKeyFn?: (data: any) => string;
}>;
declare class RowDragging extends NestedOption<IRowDraggingProps> {
    static OptionName: string;
    static ExpectedChildren: {
        cursorOffset: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type IScrollingProps = React.PropsWithChildren<{
    columnRenderingMode?: "standard" | "virtual";
    mode?: "infinite" | "standard" | "virtual";
    preloadEnabled?: boolean;
    renderAsync?: boolean;
    rowRenderingMode?: "standard" | "virtual";
    scrollByContent?: boolean;
    scrollByThumb?: boolean;
    showScrollbar?: "always" | "never" | "onHover" | "onScroll";
    useNative?: boolean | "auto";
}>;
declare class Scrolling extends NestedOption<IScrollingProps> {
    static OptionName: string;
}
declare type ISearchProps = React.PropsWithChildren<{
    editorOptions?: any;
    enabled?: boolean;
    mode?: "contains" | "startswith" | "equals";
    searchExpr?: Array<(() => any) | string> | (() => any) | string;
    timeout?: number;
}>;
declare class Search extends NestedOption<ISearchProps> {
    static OptionName: string;
}
declare type ISearchPanelProps = React.PropsWithChildren<{
    highlightCaseSensitive?: boolean;
    highlightSearchText?: boolean;
    placeholder?: string;
    searchVisibleColumnsOnly?: boolean;
    text?: string;
    visible?: boolean;
    width?: number | string;
    defaultText?: string;
    onTextChange?: (value: string) => void;
}>;
declare class SearchPanel extends NestedOption<ISearchPanelProps> {
    static OptionName: string;
    static DefaultsProps: {
        defaultText: string;
    };
}
declare type ISelectionProps = React.PropsWithChildren<{
    allowSelectAll?: boolean;
    deferred?: boolean;
    mode?: "single" | "multiple" | "none";
    selectAllMode?: "allPages" | "page";
    showCheckBoxesMode?: "always" | "none" | "onClick" | "onLongTap";
    recursive?: boolean;
    selectByClick?: boolean;
}>;
declare class Selection extends NestedOption<ISelectionProps> {
    static OptionName: string;
}
declare type IShowProps = React.PropsWithChildren<{
    complete?: (($element: any, config: AnimationConfig) => void);
    delay?: number;
    direction?: "bottom" | "left" | "right" | "top";
    duration?: number;
    easing?: string;
    from?: AnimationState;
    staggerDelay?: number;
    start?: (($element: any, config: AnimationConfig) => void);
    to?: AnimationState;
    type?: "css" | "fade" | "fadeIn" | "fadeOut" | "pop" | "slide" | "slideIn" | "slideOut";
}>;
declare class Show extends NestedOption<IShowProps> {
    static OptionName: string;
}
declare type ISortByGroupSummaryInfoProps = React.PropsWithChildren<{
    groupColumn?: string;
    sortOrder?: "asc" | "desc";
    summaryItem?: number | string;
}>;
declare class SortByGroupSummaryInfo extends NestedOption<ISortByGroupSummaryInfoProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
}
declare type ISortingProps = React.PropsWithChildren<{
    ascendingText?: string;
    clearText?: string;
    descendingText?: string;
    mode?: "single" | "multiple" | "none";
    showSortIndexes?: boolean;
}>;
declare class Sorting extends NestedOption<ISortingProps> {
    static OptionName: string;
}
declare type IStateStoringProps = React.PropsWithChildren<{
    customLoad?: (() => any);
    customSave?: ((gridState: any) => void);
    enabled?: boolean;
    savingTimeout?: number;
    storageKey?: string;
    type?: "custom" | "localStorage" | "sessionStorage";
}>;
declare class StateStoring extends NestedOption<IStateStoringProps> {
    static OptionName: string;
}
declare type IStringLengthRuleProps = React.PropsWithChildren<{
    ignoreEmptyValue?: boolean;
    max?: number;
    message?: string;
    min?: number;
    trim?: boolean;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
}>;
declare class StringLengthRule extends NestedOption<IStringLengthRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type ISummaryProps = React.PropsWithChildren<{
    calculateCustomSummary?: ((options: {
        component: dxDataGrid;
        groupIndex: number;
        name: string;
        summaryProcess: string;
        totalValue: any;
        value: any;
    }) => void);
    groupItems?: Array<Record<string, any>> | {
        alignByColumn?: boolean;
        column?: string;
        customizeText?: ((itemInfo: {
            value: string | number | Date;
            valueText: string;
        }) => string);
        displayFormat?: string;
        name?: string;
        showInColumn?: string;
        showInGroupFooter?: boolean;
        skipEmptyValues?: boolean;
        summaryType?: "avg" | "count" | "custom" | "max" | "min" | "sum";
        valueFormat?: LocalizationTypes.Format;
    }[];
    recalculateWhileEditing?: boolean;
    skipEmptyValues?: boolean;
    texts?: Record<string, any> | {
        avg?: string;
        avgOtherColumn?: string;
        count?: string;
        max?: string;
        maxOtherColumn?: string;
        min?: string;
        minOtherColumn?: string;
        sum?: string;
        sumOtherColumn?: string;
    };
    totalItems?: Array<Record<string, any>> | {
        alignment?: "center" | "left" | "right";
        column?: string;
        cssClass?: string;
        customizeText?: ((itemInfo: {
            value: string | number | Date;
            valueText: string;
        }) => string);
        displayFormat?: string;
        name?: string;
        showInColumn?: string;
        skipEmptyValues?: boolean;
        summaryType?: "avg" | "count" | "custom" | "max" | "min" | "sum";
        valueFormat?: LocalizationTypes.Format;
    }[];
}>;
declare class Summary extends NestedOption<ISummaryProps> {
    static OptionName: string;
    static ExpectedChildren: {
        groupItem: {
            optionName: string;
            isCollectionItem: boolean;
        };
        summaryTexts: {
            optionName: string;
            isCollectionItem: boolean;
        };
        texts: {
            optionName: string;
            isCollectionItem: boolean;
        };
        totalItem: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type ISummaryTextsProps = React.PropsWithChildren<{
    avg?: string;
    avgOtherColumn?: string;
    count?: string;
    max?: string;
    maxOtherColumn?: string;
    min?: string;
    minOtherColumn?: string;
    sum?: string;
    sumOtherColumn?: string;
}>;
declare class SummaryTexts extends NestedOption<ISummaryTextsProps> {
    static OptionName: string;
}
declare type ITextsProps = React.PropsWithChildren<{
    addRow?: string;
    cancelAllChanges?: string;
    cancelRowChanges?: string;
    confirmDeleteMessage?: string;
    confirmDeleteTitle?: string;
    deleteRow?: string;
    editRow?: string;
    saveAllChanges?: string;
    saveRowChanges?: string;
    undeleteRow?: string;
    validationCancelChanges?: string;
    exportAll?: string;
    exportSelectedRows?: string;
    exportTo?: string;
    groupByThisColumn?: string;
    groupContinuedMessage?: string;
    groupContinuesMessage?: string;
    ungroup?: string;
    ungroupAll?: string;
    avg?: string;
    avgOtherColumn?: string;
    count?: string;
    max?: string;
    maxOtherColumn?: string;
    min?: string;
    minOtherColumn?: string;
    sum?: string;
    sumOtherColumn?: string;
    fix?: string;
    leftPosition?: string;
    rightPosition?: string;
    unfix?: string;
    clearFilter?: string;
    createFilter?: string;
    filterEnabledHint?: string;
    cancel?: string;
    emptyValue?: string;
    ok?: string;
}>;
declare class Texts extends NestedOption<ITextsProps> {
    static OptionName: string;
}
declare type IToProps = React.PropsWithChildren<{
    left?: number;
    opacity?: number;
    position?: PositionConfig;
    scale?: number;
    top?: number;
}>;
declare class To extends NestedOption<IToProps> {
    static OptionName: string;
}
declare type IToolbarProps = React.PropsWithChildren<{
    disabled?: boolean;
    items?: Array<dxDataGridToolbarItem | "addRowButton" | "applyFilterButton" | "columnChooserButton" | "exportButton" | "groupPanel" | "revertButton" | "saveButton" | "searchPanel">;
    visible?: boolean;
}>;
declare class Toolbar extends NestedOption<IToolbarProps> {
    static OptionName: string;
    static ExpectedChildren: {
        item: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type IToolbarItemProps = React.PropsWithChildren<{
    cssClass?: string;
    disabled?: boolean;
    html?: string;
    locateInMenu?: "always" | "auto" | "never";
    location?: "after" | "before" | "center";
    menuItemTemplate?: (() => string | any) | template;
    options?: any;
    showText?: "always" | "inMenu";
    template?: ((itemData: CollectionWidgetItem, itemIndex: number, itemElement: any) => string | any) | template;
    text?: string;
    toolbar?: "bottom" | "top";
    visible?: boolean;
    widget?: "dxAutocomplete" | "dxButton" | "dxButtonGroup" | "dxCheckBox" | "dxDateBox" | "dxDropDownButton" | "dxMenu" | "dxSelectBox" | "dxSwitch" | "dxTabs" | "dxTextBox";
    menuItemRender?: (...params: any) => React.ReactNode;
    menuItemComponent?: React.ComponentType<any>;
    menuItemKeyFn?: (data: any) => string;
    render?: (...params: any) => React.ReactNode;
    component?: React.ComponentType<any>;
    keyFn?: (data: any) => string;
}>;
declare class ToolbarItem extends NestedOption<IToolbarItemProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static TemplateProps: {
        tmplOption: string;
        render: string;
        component: string;
        keyFn: string;
    }[];
}
declare type ITotalItemProps = React.PropsWithChildren<{
    alignment?: "center" | "left" | "right";
    column?: string;
    cssClass?: string;
    customizeText?: ((itemInfo: {
        value: string | number | Date;
        valueText: string;
    }) => string);
    displayFormat?: string;
    name?: string;
    showInColumn?: string;
    skipEmptyValues?: boolean;
    summaryType?: "avg" | "count" | "custom" | "max" | "min" | "sum";
    valueFormat?: LocalizationTypes.Format;
}>;
declare class TotalItem extends NestedOption<ITotalItemProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static ExpectedChildren: {
        valueFormat: {
            optionName: string;
            isCollectionItem: boolean;
        };
    };
}
declare type IValidationRuleProps = React.PropsWithChildren<{
    message?: string;
    trim?: boolean;
    type?: "required" | "numeric" | "range" | "stringLength" | "custom" | "compare" | "pattern" | "email" | "async";
    ignoreEmptyValue?: boolean;
    max?: Date | number | string;
    min?: Date | number | string;
    reevaluate?: boolean;
    validationCallback?: ((options: {
        column: Record<string, any>;
        data: Record<string, any>;
        formItem: Record<string, any>;
        rule: Record<string, any>;
        validator: Record<string, any>;
        value: string | number;
    }) => boolean);
    comparisonTarget?: (() => any);
    comparisonType?: "!=" | "!==" | "<" | "<=" | "==" | "===" | ">" | ">=";
    pattern?: RegExp | string;
}>;
declare class ValidationRule extends NestedOption<IValidationRuleProps> {
    static OptionName: string;
    static IsCollectionItem: boolean;
    static PredefinedProps: {
        type: string;
    };
}
declare type IValueFormatProps = React.PropsWithChildren<{
    currency?: string;
    formatter?: ((value: number | Date) => string);
    parser?: ((value: string) => number | Date);
    precision?: number;
    type?: "billions" | "currency" | "day" | "decimal" | "exponential" | "fixedPoint" | "largeNumber" | "longDate" | "longTime" | "millions" | "millisecond" | "month" | "monthAndDay" | "monthAndYear" | "percent" | "quarter" | "quarterAndYear" | "shortDate" | "shortTime" | "thousands" | "trillions" | "year" | "dayOfWeek" | "hour" | "longDateLongTime" | "minute" | "second" | "shortDateShortTime";
    useCurrencyAccountingStyle?: boolean;
}>;
declare class ValueFormat extends NestedOption<IValueFormatProps> {
    static OptionName: string;
}
export default DataGrid;
export { DataGrid, IDataGridOptions, Animation, IAnimationProps, AsyncRule, IAsyncRuleProps, At, IAtProps, BoundaryOffset, IBoundaryOffsetProps, Button, IButtonProps, Change, IChangeProps, ColCountByScreen, IColCountByScreenProps, Collision, ICollisionProps, Column, IColumnProps, ColumnChooser, IColumnChooserProps, ColumnChooserSearch, IColumnChooserSearchProps, ColumnChooserSelection, IColumnChooserSelectionProps, ColumnFixing, IColumnFixingProps, ColumnFixingTexts, IColumnFixingTextsProps, ColumnHeaderFilter, IColumnHeaderFilterProps, ColumnHeaderFilterSearch, IColumnHeaderFilterSearchProps, ColumnLookup, IColumnLookupProps, CompareRule, ICompareRuleProps, CursorOffset, ICursorOffsetProps, CustomOperation, ICustomOperationProps, CustomRule, ICustomRuleProps, DataGridHeaderFilter, IDataGridHeaderFilterProps, DataGridHeaderFilterSearch, IDataGridHeaderFilterSearchProps, DataGridHeaderFilterTexts, IDataGridHeaderFilterTextsProps, DataGridSelection, IDataGridSelectionProps, Editing, IEditingProps, EditingTexts, IEditingTextsProps, EmailRule, IEmailRuleProps, Export, IExportProps, ExportTexts, IExportTextsProps, Field, IFieldProps, FieldLookup, IFieldLookupProps, FilterBuilder, IFilterBuilderProps, FilterBuilderPopup, IFilterBuilderPopupProps, FilterOperationDescriptions, IFilterOperationDescriptionsProps, FilterPanel, IFilterPanelProps, FilterPanelTexts, IFilterPanelTextsProps, FilterRow, IFilterRowProps, Form, IFormProps, Format, IFormatProps, FormItem, IFormItemProps, From, IFromProps, Grouping, IGroupingProps, GroupingTexts, IGroupingTextsProps, GroupItem, IGroupItemProps, GroupOperationDescriptions, IGroupOperationDescriptionsProps, GroupPanel, IGroupPanelProps, HeaderFilter, IHeaderFilterProps, Hide, IHideProps, Item, IItemProps, KeyboardNavigation, IKeyboardNavigationProps, Label, ILabelProps, LoadPanel, ILoadPanelProps, Lookup, ILookupProps, MasterDetail, IMasterDetailProps, My, IMyProps, NumericRule, INumericRuleProps, Offset, IOffsetProps, OperationDescriptions, IOperationDescriptionsProps, Pager, IPagerProps, Paging, IPagingProps, PatternRule, IPatternRuleProps, Popup, IPopupProps, Position, IPositionProps, RangeRule, IRangeRuleProps, RemoteOperations, IRemoteOperationsProps, RequiredRule, IRequiredRuleProps, RowDragging, IRowDraggingProps, Scrolling, IScrollingProps, Search, ISearchProps, SearchPanel, ISearchPanelProps, Selection, ISelectionProps, Show, IShowProps, SortByGroupSummaryInfo, ISortByGroupSummaryInfoProps, Sorting, ISortingProps, StateStoring, IStateStoringProps, StringLengthRule, IStringLengthRuleProps, Summary, ISummaryProps, SummaryTexts, ISummaryTextsProps, Texts, ITextsProps, To, IToProps, Toolbar, IToolbarProps, ToolbarItem, IToolbarItemProps, TotalItem, ITotalItemProps, ValidationRule, IValidationRuleProps, ValueFormat, IValueFormatProps };
import type * as DataGridTypes from 'devextreme/ui/data_grid_types';
export { DataGridTypes };
