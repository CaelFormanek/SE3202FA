{"version":3,"file":"parchment.js","mappings":"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","sources":["webpack://Parchment/webpack/universalModuleDefinition","webpack://Parchment/webpack/bootstrap","webpack://Parchment/./src/scope.ts","webpack://Parchment/webpack/runtime/define property getters","webpack://Parchment/webpack/runtime/hasOwnProperty shorthand","webpack://Parchment/webpack/runtime/make namespace object","webpack://Parchment/./src/error.ts","webpack://Parchment/./src/registry.ts","webpack://Parchment/./src/blot/abstract/shadow.ts","webpack://Parchment/./src/blot/abstract/parent.ts","webpack://Parchment/./src/collection/linked-list.ts","webpack://Parchment/./src/blot/abstract/container.ts","webpack://Parchment/./src/blot/abstract/leaf.ts","webpack://Parchment/./src/attributor/attributor.ts","webpack://Parchment/./src/attributor/class.ts","webpack://Parchment/./src/attributor/style.ts","webpack://Parchment/./src/attributor/store.ts","webpack://Parchment/./src/blot/inline.ts","webpack://Parchment/./src/blot/block.ts","webpack://Parchment/./src/blot/embed.ts","webpack://Parchment/./src/blot/scroll.ts","webpack://Parchment/./src/blot/text.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Parchment\"] = factory();\n\telse\n\t\troot[\"Parchment\"] = factory();\n})((() => {\n        if (typeof self !== 'undefined') {\n            return self;\n        } else if (typeof window !== 'undefined') {\n            return window;\n        } else if (typeof global !== 'undefined') {\n            return global;\n        } else {\n            return Function('return this')();\n        }\n    })(), function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","enum Scope {\n  TYPE = (1 << 2) - 1, // 0011 Lower two bits\n  LEVEL = ((1 << 2) - 1) << 2, // 1100 Higher two bits\n\n  ATTRIBUTE = (1 << 0) | LEVEL, // 1101\n  BLOT = (1 << 1) | LEVEL, // 1110\n  INLINE = (1 << 2) | TYPE, // 0111\n  BLOCK = (1 << 3) | TYPE, // 1011\n\n  BLOCK_BLOT = BLOCK & BLOT, // 1010\n  INLINE_BLOT = INLINE & BLOT, // 0110\n  BLOCK_ATTRIBUTE = BLOCK & ATTRIBUTE, // 1001\n  INLINE_ATTRIBUTE = INLINE & ATTRIBUTE, // 0101\n\n  ANY = TYPE | LEVEL,\n}\n\nexport default Scope;\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export default class ParchmentError extends Error {\n  public message: string;\n  public name: string;\n  public stack!: string;\n\n  constructor(message: string) {\n    message = '[Parchment] ' + message;\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n  }\n}\n","import Attributor from './attributor/attributor';\nimport { Blot, BlotConstructor, Root } from './blot/abstract/blot';\nimport ParchmentError from './error';\nimport Scope from './scope';\n\nexport interface RegistryInterface {\n  create(sroll: Root, input: Node | string | Scope, value?: any): Blot;\n  query(\n    query: string | Node | Scope,\n    scope: Scope,\n  ): Attributor | BlotConstructor | null;\n  register(...definitions: any[]): any;\n}\n\nexport default class Registry implements RegistryInterface {\n  public static blots = new WeakMap<Node, Blot>();\n\n  public static find(node: Node | null, bubble = false): Blot | null {\n    if (node == null) {\n      return null;\n    }\n    if (this.blots.has(node)) {\n      return this.blots.get(node) || null;\n    }\n    if (bubble) {\n      let parentNode: Node | null = null;\n      try {\n        parentNode = node.parentNode;\n      } catch (err) {\n        // Probably hit a permission denied error.\n        // A known case is in Firefox, event targets can be anonymous DIVs\n        // inside an input element.\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n        return null;\n      }\n      return this.find(parentNode, bubble);\n    }\n    return null;\n  }\n\n  private attributes: { [key: string]: Attributor } = {};\n  private classes: { [key: string]: BlotConstructor } = {};\n  private tags: { [key: string]: BlotConstructor } = {};\n  private types: { [key: string]: Attributor | BlotConstructor } = {};\n\n  public create(scroll: Root, input: Node | string | Scope, value?: any): Blot {\n    const match = this.query(input);\n    if (match == null) {\n      throw new ParchmentError(`Unable to create ${input} blot`);\n    }\n    const blotClass = match as BlotConstructor;\n    const node =\n      // @ts-expect-error\n      input instanceof Node || input.nodeType === Node.TEXT_NODE\n        ? input\n        : blotClass.create(value);\n\n    const blot = new blotClass(scroll, node as Node, value);\n    Registry.blots.set(blot.domNode, blot);\n    return blot;\n  }\n\n  public find(node: Node | null, bubble = false): Blot | null {\n    return Registry.find(node, bubble);\n  }\n\n  public query(\n    query: string | Node | Scope,\n    scope: Scope = Scope.ANY,\n  ): Attributor | BlotConstructor | null {\n    let match;\n    if (typeof query === 'string') {\n      match = this.types[query] || this.attributes[query];\n      // @ts-expect-error\n    } else if (query instanceof Text || query.nodeType === Node.TEXT_NODE) {\n      match = this.types.text;\n    } else if (typeof query === 'number') {\n      if (query & Scope.LEVEL & Scope.BLOCK) {\n        match = this.types.block;\n      } else if (query & Scope.LEVEL & Scope.INLINE) {\n        match = this.types.inline;\n      }\n    } else if (query instanceof Element) {\n      const names = (query.getAttribute('class') || '').split(/\\s+/);\n      names.some((name) => {\n        match = this.classes[name];\n        if (match) {\n          return true;\n        }\n        return false;\n      });\n      match = match || this.tags[query.tagName];\n    }\n    if (match == null) {\n      return null;\n    }\n    // @ts-expect-error\n    if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope) {\n      return match;\n    }\n    return null;\n  }\n\n  public register(...definitions: any[]): any {\n    if (definitions.length > 1) {\n      return definitions.map((d) => {\n        return this.register(d);\n      });\n    }\n    const definition = definitions[0];\n    if (\n      typeof definition.blotName !== 'string' &&\n      typeof definition.attrName !== 'string'\n    ) {\n      throw new ParchmentError('Invalid definition');\n    } else if (definition.blotName === 'abstract') {\n      throw new ParchmentError('Cannot register abstract class');\n    }\n    this.types[definition.blotName || definition.attrName] = definition;\n    if (typeof definition.keyName === 'string') {\n      this.attributes[definition.keyName] = definition;\n    } else {\n      if (definition.className != null) {\n        this.classes[definition.className] = definition;\n      }\n      if (definition.tagName != null) {\n        if (Array.isArray(definition.tagName)) {\n          definition.tagName = definition.tagName.map((tagName: string) => {\n            return tagName.toUpperCase();\n          });\n        } else {\n          definition.tagName = definition.tagName.toUpperCase();\n        }\n        const tagNames = Array.isArray(definition.tagName)\n          ? definition.tagName\n          : [definition.tagName];\n        tagNames.forEach((tag: string) => {\n          if (this.tags[tag] == null || definition.className == null) {\n            this.tags[tag] = definition;\n          }\n        });\n      }\n    }\n    return definition;\n  }\n}\n","import ParchmentError from '../../error';\nimport Registry from '../../registry';\nimport Scope from '../../scope';\nimport { Blot, BlotConstructor, Formattable, Parent, Root } from './blot';\n\nclass ShadowBlot implements Blot {\n  public static blotName = 'abstract';\n  public static className: string;\n  public static requiredContainer: BlotConstructor;\n  public static scope: Scope;\n  public static tagName: string;\n\n  public static create(value: any): Node {\n    if (this.tagName == null) {\n      throw new ParchmentError('Blot definition missing tagName');\n    }\n    let node;\n    if (Array.isArray(this.tagName)) {\n      if (typeof value === 'string') {\n        value = value.toUpperCase();\n        if (parseInt(value, 10).toString() === value) {\n          value = parseInt(value, 10);\n        }\n      }\n      if (typeof value === 'number') {\n        node = document.createElement(this.tagName[value - 1]);\n      } else if (this.tagName.indexOf(value) > -1) {\n        node = document.createElement(value);\n      } else {\n        node = document.createElement(this.tagName[0]);\n      }\n    } else {\n      node = document.createElement(this.tagName);\n    }\n    if (this.className) {\n      node.classList.add(this.className);\n    }\n    return node;\n  }\n\n  public prev: Blot | null;\n  public next: Blot | null;\n  // @ts-expect-error\n  public parent: Parent;\n\n  // Hack for accessing inherited static methods\n  get statics(): any {\n    return this.constructor;\n  }\n  constructor(public scroll: Root, public domNode: Node) {\n    Registry.blots.set(domNode, this);\n    this.prev = null;\n    this.next = null;\n  }\n\n  public attach(): void {\n    // Nothing to do\n  }\n\n  public clone(): Blot {\n    const domNode = this.domNode.cloneNode(false);\n    return this.scroll.create(domNode);\n  }\n\n  public detach(): void {\n    if (this.parent != null) {\n      this.parent.removeChild(this);\n    }\n    Registry.blots.delete(this.domNode);\n  }\n\n  public deleteAt(index: number, length: number): void {\n    const blot = this.isolate(index, length);\n    blot.remove();\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    const blot = this.isolate(index, length);\n    if (this.scroll.query(name, Scope.BLOT) != null && value) {\n      blot.wrap(name, value);\n    } else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {\n      const parent = this.scroll.create(this.statics.scope) as Parent &\n        Formattable;\n      blot.wrap(parent);\n      parent.format(name, value);\n    }\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    const blot =\n      def == null\n        ? this.scroll.create('text', value)\n        : this.scroll.create(value, def);\n    const ref = this.split(index);\n    this.parent.insertBefore(blot, ref || undefined);\n  }\n\n  public isolate(index: number, length: number): Blot {\n    const target = this.split(index);\n    if (target == null) {\n      throw new Error('Attempt to isolate at end');\n    }\n    target.split(length);\n    return target;\n  }\n\n  public length(): number {\n    return 1;\n  }\n\n  public offset(root: Blot = this.parent): number {\n    if (this.parent == null || this === root) {\n      return 0;\n    }\n    return this.parent.children.offset(this) + this.parent.offset(root);\n  }\n\n  public optimize(_context: { [key: string]: any }): void {\n    if (\n      this.statics.requiredContainer &&\n      !(this.parent instanceof this.statics.requiredContainer)\n    ) {\n      this.wrap(this.statics.requiredContainer.blotName);\n    }\n  }\n\n  public remove(): void {\n    if (this.domNode.parentNode != null) {\n      this.domNode.parentNode.removeChild(this.domNode);\n    }\n    this.detach();\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement =\n      typeof name === 'string' ? this.scroll.create(name, value) : name;\n    if (this.parent != null) {\n      this.parent.insertBefore(replacement, this.next || undefined);\n      this.remove();\n    }\n    return replacement;\n  }\n\n  public split(index: number, _force?: boolean): Blot | null {\n    return index === 0 ? this : this.next;\n  }\n\n  public update(\n    _mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    // Nothing to do by default\n  }\n\n  public wrap(name: string | Parent, value?: any): Parent {\n    const wrapper =\n      typeof name === 'string'\n        ? (this.scroll.create(name, value) as Parent)\n        : name;\n    if (this.parent != null) {\n      this.parent.insertBefore(wrapper, this.next || undefined);\n    }\n    if (typeof wrapper.appendChild !== 'function') {\n      throw new ParchmentError(`Cannot wrap ${name}`);\n    }\n    wrapper.appendChild(this);\n    return wrapper;\n  }\n}\n\nexport default ShadowBlot;\n","import LinkedList from '../../collection/linked-list';\nimport ParchmentError from '../../error';\nimport Scope from '../../scope';\nimport { Blot, BlotConstructor, Parent, Root } from './blot';\nimport ShadowBlot from './shadow';\n\nfunction makeAttachedBlot(node: Node, scroll: Root): Blot {\n  let blot = scroll.find(node);\n  if (blot == null) {\n    try {\n      blot = scroll.create(node);\n    } catch (e) {\n      blot = scroll.create(Scope.INLINE) as Blot;\n      Array.from(node.childNodes).forEach((child: Node) => {\n        // @ts-expect-error\n        blot.domNode.appendChild(child);\n      });\n      if (node.parentNode) {\n        node.parentNode.replaceChild(blot.domNode, node);\n      }\n      blot.attach();\n    }\n  }\n  return blot as Blot;\n}\n\nclass ParentBlot extends ShadowBlot implements Parent {\n  public static allowedChildren: BlotConstructor[] | null;\n  public static defaultChild: BlotConstructor | null;\n  public static uiClass = '';\n\n  public children!: LinkedList<Blot>;\n  public domNode!: HTMLElement;\n  public uiNode: HTMLElement | null = null;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.build();\n  }\n\n  public appendChild(other: Blot): void {\n    this.insertBefore(other);\n  }\n\n  public attach(): void {\n    super.attach();\n    this.children.forEach((child) => {\n      child.attach();\n    });\n  }\n\n  public attachUI(node: HTMLElement): void {\n    if (this.uiNode != null) {\n      this.uiNode.remove();\n    }\n    this.uiNode = node;\n    if (ParentBlot.uiClass) {\n      this.uiNode.classList.add(ParentBlot.uiClass);\n    }\n    this.uiNode.setAttribute('contenteditable', 'false');\n    this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n  }\n\n  public build(): void {\n    this.children = new LinkedList<Blot>();\n    // Need to be reversed for if DOM nodes already in order\n    Array.from(this.domNode.childNodes)\n      .filter((node: Node) => node !== this.uiNode)\n      .reverse()\n      .forEach((node: Node) => {\n        try {\n          const child = makeAttachedBlot(node, this.scroll);\n          this.insertBefore(child, this.children.head || undefined);\n        } catch (err) {\n          if (err instanceof ParchmentError) {\n            return;\n          } else {\n            throw err;\n          }\n        }\n      });\n  }\n\n  public deleteAt(index: number, length: number): void {\n    if (index === 0 && length === this.length()) {\n      return this.remove();\n    }\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.deleteAt(offset, childLength);\n    });\n  }\n\n  public descendant(\n    criteria: new () => Blot,\n    index: number,\n  ): [Blot | null, number];\n  public descendant(\n    criteria: (blot: Blot) => boolean,\n    index: number,\n  ): [Blot | null, number];\n  public descendant(criteria: any, index = 0): [Blot | null, number] {\n    const [child, offset] = this.children.find(index);\n    if (\n      (criteria.blotName == null && criteria(child)) ||\n      (criteria.blotName != null && child instanceof criteria)\n    ) {\n      return [child as any, offset];\n    } else if (child instanceof ParentBlot) {\n      return child.descendant(criteria, offset);\n    } else {\n      return [null, -1];\n    }\n  }\n\n  public descendants(\n    criteria: new () => Blot,\n    index: number,\n    length: number,\n  ): Blot[];\n  public descendants(\n    criteria: (blot: Blot) => boolean,\n    index: number,\n    length: number,\n  ): Blot[];\n  public descendants(\n    criteria: any,\n    index = 0,\n    length: number = Number.MAX_VALUE,\n  ): Blot[] {\n    let descendants: Blot[] = [];\n    let lengthLeft = length;\n    this.children.forEachAt(\n      index,\n      length,\n      (child: Blot, childIndex: number, childLength: number) => {\n        if (\n          (criteria.blotName == null && criteria(child)) ||\n          (criteria.blotName != null && child instanceof criteria)\n        ) {\n          descendants.push(child);\n        }\n        if (child instanceof ParentBlot) {\n          descendants = descendants.concat(\n            child.descendants(criteria, childIndex, lengthLeft),\n          );\n        }\n        lengthLeft -= childLength;\n      },\n    );\n    return descendants;\n  }\n\n  public detach(): void {\n    this.children.forEach((child) => {\n      child.detach();\n    });\n    super.detach();\n  }\n\n  public enforceAllowedChildren(): void {\n    let done = false;\n    this.children.forEach((child: Blot) => {\n      if (done) {\n        return;\n      }\n      const allowed = this.statics.allowedChildren.some(\n        (def: BlotConstructor) => child instanceof def,\n      );\n      if (allowed) {\n        return;\n      }\n      if (child.statics.scope === Scope.BLOCK_BLOT) {\n        if (child.next != null) {\n          this.splitAfter(child);\n        }\n        if (child.prev != null) {\n          this.splitAfter(child.prev);\n        }\n        child.parent.unwrap();\n        done = true;\n      } else if (child instanceof ParentBlot) {\n        child.unwrap();\n      } else {\n        child.remove();\n      }\n    });\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.formatAt(offset, childLength, name, value);\n    });\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    const [child, offset] = this.children.find(index);\n    if (child) {\n      child.insertAt(offset, value, def);\n    } else {\n      const blot =\n        def == null\n          ? this.scroll.create('text', value)\n          : this.scroll.create(value, def);\n      this.appendChild(blot);\n    }\n  }\n\n  public insertBefore(childBlot: Blot, refBlot?: Blot | null): void {\n    if (childBlot.parent != null) {\n      childBlot.parent.children.remove(childBlot);\n    }\n    let refDomNode: Node | null = null;\n    this.children.insertBefore(childBlot, refBlot || null);\n    childBlot.parent = this;\n    if (refBlot != null) {\n      refDomNode = refBlot.domNode;\n    }\n    if (\n      this.domNode.parentNode !== childBlot.domNode ||\n      this.domNode.nextSibling !== refDomNode\n    ) {\n      this.domNode.insertBefore(childBlot.domNode, refDomNode);\n    }\n    childBlot.attach();\n  }\n\n  public length(): number {\n    return this.children.reduce((memo, child) => {\n      return memo + child.length();\n    }, 0);\n  }\n\n  public moveChildren(targetParent: Parent, refNode?: Blot): void {\n    this.children.forEach((child) => {\n      targetParent.insertBefore(child, refNode);\n    });\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    this.enforceAllowedChildren();\n    if (this.uiNode != null && this.uiNode !== this.domNode.firstChild) {\n      this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n    }\n    if (this.children.length === 0) {\n      if (this.statics.defaultChild != null) {\n        const child = this.scroll.create(this.statics.defaultChild.blotName);\n        this.appendChild(child);\n        // TODO double check if necessary\n        // child.optimize(context);\n      } else {\n        this.remove();\n      }\n    }\n  }\n\n  public path(index: number, inclusive = false): [Blot, number][] {\n    const [child, offset] = this.children.find(index, inclusive);\n    const position: [Blot, number][] = [[this, index]];\n    if (child instanceof ParentBlot) {\n      return position.concat(child.path(offset, inclusive));\n    } else if (child != null) {\n      position.push([child, offset]);\n    }\n    return position;\n  }\n\n  public removeChild(child: Blot): void {\n    this.children.remove(child);\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement =\n      typeof name === 'string' ? this.scroll.create(name, value) : name;\n    if (replacement instanceof ParentBlot) {\n      this.moveChildren(replacement);\n    }\n    return super.replaceWith(replacement);\n  }\n\n  public split(index: number, force = false): Blot | null {\n    if (!force) {\n      if (index === 0) {\n        return this;\n      }\n      if (index === this.length()) {\n        return this.next;\n      }\n    }\n    const after = this.clone() as ParentBlot;\n    if (this.parent) {\n      this.parent.insertBefore(after, this.next || undefined);\n    }\n    this.children.forEachAt(index, this.length(), (child, offset, _length) => {\n      const split = child.split(offset, force);\n      if (split != null) {\n        after.appendChild(split);\n      }\n    });\n    return after;\n  }\n\n  public splitAfter(child: Blot): Parent {\n    const after = this.clone() as ParentBlot;\n    while (child.next != null) {\n      after.appendChild(child.next);\n    }\n    if (this.parent) {\n      this.parent.insertBefore(after, this.next || undefined);\n    }\n    return after;\n  }\n\n  public unwrap(): void {\n    if (this.parent) {\n      this.moveChildren(this.parent, this.next || undefined);\n    }\n    this.remove();\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    const addedNodes: Node[] = [];\n    const removedNodes: Node[] = [];\n    mutations.forEach((mutation) => {\n      if (mutation.target === this.domNode && mutation.type === 'childList') {\n        addedNodes.push(...mutation.addedNodes);\n        removedNodes.push(...mutation.removedNodes);\n      }\n    });\n    removedNodes.forEach((node: Node) => {\n      // Check node has actually been removed\n      // One exception is Chrome does not immediately remove IFRAMEs\n      // from DOM but MutationRecord is correct in its reported removal\n      if (\n        node.parentNode != null &&\n        // @ts-expect-error\n        node.tagName !== 'IFRAME' &&\n        document.body.compareDocumentPosition(node) &\n          Node.DOCUMENT_POSITION_CONTAINED_BY\n      ) {\n        return;\n      }\n      const blot = this.scroll.find(node);\n      if (blot == null) {\n        return;\n      }\n      if (\n        blot.domNode.parentNode == null ||\n        blot.domNode.parentNode === this.domNode\n      ) {\n        blot.detach();\n      }\n    });\n    addedNodes\n      .filter((node) => {\n        return node.parentNode === this.domNode || node === this.uiNode;\n      })\n      .sort((a, b) => {\n        if (a === b) {\n          return 0;\n        }\n        if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {\n          return 1;\n        }\n        return -1;\n      })\n      .forEach((node) => {\n        let refBlot: Blot | null = null;\n        if (node.nextSibling != null) {\n          refBlot = this.scroll.find(node.nextSibling);\n        }\n        const blot = makeAttachedBlot(node, this.scroll);\n        if (blot.next !== refBlot || blot.next == null) {\n          if (blot.parent != null) {\n            blot.parent.removeChild(this);\n          }\n          this.insertBefore(blot, refBlot || undefined);\n        }\n      });\n    this.enforceAllowedChildren();\n  }\n}\n\nexport default ParentBlot;\n","import LinkedNode from './linked-node';\n\nclass LinkedList<T extends LinkedNode> {\n  public head: T | null;\n  public tail: T | null;\n  public length: number;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  public append(...nodes: T[]): void {\n    this.insertBefore(nodes[0], null);\n    if (nodes.length > 1) {\n      const rest = nodes.slice(1);\n      this.append(...rest);\n    }\n  }\n\n  public at(index: number): T | null {\n    const next = this.iterator();\n    let cur = next();\n    while (cur && index > 0) {\n      index -= 1;\n      cur = next();\n    }\n    return cur;\n  }\n\n  public contains(node: T): boolean {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      if (cur === node) {\n        return true;\n      }\n      cur = next();\n    }\n    return false;\n  }\n\n  public indexOf(node: T): number {\n    const next = this.iterator();\n    let cur = next();\n    let index = 0;\n    while (cur) {\n      if (cur === node) {\n        return index;\n      }\n      index += 1;\n      cur = next();\n    }\n    return -1;\n  }\n\n  public insertBefore(node: T | null, refNode: T | null): void {\n    if (node == null) {\n      return;\n    }\n    this.remove(node);\n    node.next = refNode;\n    if (refNode != null) {\n      node.prev = refNode.prev;\n      if (refNode.prev != null) {\n        refNode.prev.next = node;\n      }\n      refNode.prev = node;\n      if (refNode === this.head) {\n        this.head = node;\n      }\n    } else if (this.tail != null) {\n      this.tail.next = node;\n      node.prev = this.tail;\n      this.tail = node;\n    } else {\n      node.prev = null;\n      this.head = this.tail = node;\n    }\n    this.length += 1;\n  }\n\n  public offset(target: T): number {\n    let index = 0;\n    let cur = this.head;\n    while (cur != null) {\n      if (cur === target) {\n        return index;\n      }\n      index += cur.length();\n      cur = cur.next as T;\n    }\n    return -1;\n  }\n\n  public remove(node: T): void {\n    if (!this.contains(node)) {\n      return;\n    }\n    if (node.prev != null) {\n      node.prev.next = node.next;\n    }\n    if (node.next != null) {\n      node.next.prev = node.prev;\n    }\n    if (node === this.head) {\n      this.head = node.next as T;\n    }\n    if (node === this.tail) {\n      this.tail = node.prev as T;\n    }\n    this.length -= 1;\n  }\n\n  public iterator(curNode: T | null = this.head): () => T | null {\n    // TODO use yield when we can\n    return (): T | null => {\n      const ret = curNode;\n      if (curNode != null) {\n        curNode = curNode.next as T;\n      }\n      return ret;\n    };\n  }\n\n  public find(index: number, inclusive = false): [T | null, number] {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      const length = cur.length();\n      if (\n        index < length ||\n        (inclusive &&\n          index === length &&\n          (cur.next == null || cur.next.length() !== 0))\n      ) {\n        return [cur, index];\n      }\n      index -= length;\n      cur = next();\n    }\n    return [null, 0];\n  }\n\n  public forEach(callback: (cur: T) => void): void {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      callback(cur);\n      cur = next();\n    }\n  }\n\n  public forEachAt(\n    index: number,\n    length: number,\n    callback: (cur: T, offset: number, length: number) => void,\n  ): void {\n    if (length <= 0) {\n      return;\n    }\n    const [startNode, offset] = this.find(index);\n    let curIndex = index - offset;\n    const next = this.iterator(startNode);\n    let cur = next();\n    while (cur && curIndex < index + length) {\n      const curLength = cur.length();\n      if (index > curIndex) {\n        callback(\n          cur,\n          index - curIndex,\n          Math.min(length, curIndex + curLength - index),\n        );\n      } else {\n        callback(cur, 0, Math.min(curLength, index + length - curIndex));\n      }\n      curIndex += curLength;\n      cur = next();\n    }\n  }\n\n  public map(callback: (cur: T) => any): any[] {\n    return this.reduce((memo: T[], cur: T) => {\n      memo.push(callback(cur));\n      return memo;\n    }, []);\n  }\n\n  public reduce<M>(callback: (memo: M, cur: T) => M, memo: M): M {\n    const next = this.iterator();\n    let cur = next();\n    while (cur) {\n      memo = callback(memo, cur);\n      cur = next();\n    }\n    return memo;\n  }\n}\n\nexport default LinkedList;\n","import Scope from '../../scope';\nimport BlockBlot from '../block';\nimport ParentBlot from './parent';\n\nclass ContainerBlot extends ParentBlot {\n  public static blotName = 'container';\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName: string;\n\n  public prev!: BlockBlot | ContainerBlot | null;\n  public next!: BlockBlot | ContainerBlot | null;\n\n  public checkMerge(): boolean {\n    return (\n      this.next !== null && this.next.statics.blotName === this.statics.blotName\n    );\n  }\n\n  public deleteAt(index: number, length: number): void {\n    super.deleteAt(index, length);\n    this.enforceAllowedChildren();\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    super.formatAt(index, length, name, value);\n    this.enforceAllowedChildren();\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    super.insertAt(index, value, def);\n    this.enforceAllowedChildren();\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    if (this.children.length > 0 && this.next != null && this.checkMerge()) {\n      this.next.moveChildren(this);\n      this.next.remove();\n    }\n  }\n}\n\nexport default ContainerBlot;\n","import Scope from '../../scope';\nimport { Leaf } from './blot';\nimport ShadowBlot from './shadow';\n\nclass LeafBlot extends ShadowBlot implements Leaf {\n  public static scope = Scope.INLINE_BLOT;\n\n  public static value(_domNode: Node): any {\n    return true;\n  }\n\n  public index(node: Node, offset: number): number {\n    if (\n      this.domNode === node ||\n      this.domNode.compareDocumentPosition(node) &\n        Node.DOCUMENT_POSITION_CONTAINED_BY\n    ) {\n      return Math.min(offset, 1);\n    }\n    return -1;\n  }\n\n  public position(index: number, _inclusive?: boolean): [Node, number] {\n    const childNodes: Node[] = Array.from(this.parent.domNode.childNodes);\n    let offset = childNodes.indexOf(this.domNode);\n    if (index > 0) {\n      offset += 1;\n    }\n    return [this.parent.domNode, offset];\n  }\n\n  public value(): any {\n    return {\n      [this.statics.blotName]: this.statics.value(this.domNode) || true,\n    };\n  }\n}\n\nexport default LeafBlot;\n","import Scope from '../scope';\n\nexport interface AttributorOptions {\n  scope?: Scope;\n  whitelist?: string[];\n}\n\nexport default class Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return Array.from(node.attributes).map((item: Attr) => item.name);\n  }\n\n  public attrName: string;\n  public keyName: string;\n  public scope: Scope;\n  public whitelist: string[] | undefined;\n\n  constructor(\n    attrName: string,\n    keyName: string,\n    options: AttributorOptions = {},\n  ) {\n    this.attrName = attrName;\n    this.keyName = keyName;\n    const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;\n    this.scope =\n      options.scope != null\n        ? // Ignore type bits, force attribute bit\n          (options.scope & Scope.LEVEL) | attributeBit\n        : Scope.ATTRIBUTE;\n    if (options.whitelist != null) {\n      this.whitelist = options.whitelist;\n    }\n  }\n\n  public add(node: HTMLElement, value: string): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    node.setAttribute(this.keyName, value);\n    return true;\n  }\n\n  public canAdd(_node: HTMLElement, value: any): boolean {\n    if (this.whitelist == null) {\n      return true;\n    }\n    if (typeof value === 'string') {\n      return this.whitelist.indexOf(value.replace(/[\"']/g, '')) > -1;\n    } else {\n      return this.whitelist.indexOf(value) > -1;\n    }\n  }\n\n  public remove(node: HTMLElement): void {\n    node.removeAttribute(this.keyName);\n  }\n\n  public value(node: HTMLElement): string {\n    const value = node.getAttribute(this.keyName);\n    if (this.canAdd(node, value) && value) {\n      return value;\n    }\n    return '';\n  }\n}\n","import Attributor from './attributor';\n\nfunction match(node: HTMLElement, prefix: string): string[] {\n  const className = node.getAttribute('class') || '';\n  return className\n    .split(/\\s+/)\n    .filter((name) => name.indexOf(`${prefix}-`) === 0);\n}\n\nclass ClassAttributor extends Attributor {\n  public static keys(node: HTMLElement): string[] {\n    return (node.getAttribute('class') || '')\n      .split(/\\s+/)\n      .map((name) => name.split('-').slice(0, -1).join('-'));\n  }\n\n  public add(node: HTMLElement, value: string): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    this.remove(node);\n    node.classList.add(`${this.keyName}-${value}`);\n    return true;\n  }\n\n  public remove(node: HTMLElement): void {\n    const matches = match(node, this.keyName);\n    matches.forEach((name) => {\n      node.classList.remove(name);\n    });\n    if (node.classList.length === 0) {\n      node.removeAttribute('class');\n    }\n  }\n\n  public value(node: HTMLElement): string {\n    const result = match(node, this.keyName)[0] || '';\n    const value = result.slice(this.keyName.length + 1); // +1 for hyphen\n    return this.canAdd(node, value) ? value : '';\n  }\n}\n\nexport default ClassAttributor;\n","import Attributor from './attributor';\n\nfunction camelize(name: string): string {\n  const parts = name.split('-');\n  const rest = parts\n    .slice(1)\n    .map((part: string) => part[0].toUpperCase() + part.slice(1))\n    .join('');\n  return parts[0] + rest;\n}\n\nclass StyleAttributor extends Attributor {\n  public static keys(node: Element): string[] {\n    return (node.getAttribute('style') || '').split(';').map((value) => {\n      const arr = value.split(':');\n      return arr[0].trim();\n    });\n  }\n\n  public add(node: HTMLElement, value: string): boolean {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n    // @ts-expect-error\n    node.style[camelize(this.keyName)] = value;\n    return true;\n  }\n\n  public remove(node: HTMLElement): void {\n    // @ts-expect-error\n    node.style[camelize(this.keyName)] = '';\n    if (!node.getAttribute('style')) {\n      node.removeAttribute('style');\n    }\n  }\n\n  public value(node: HTMLElement): string {\n    // @ts-expect-error\n    const value = node.style[camelize(this.keyName)];\n    return this.canAdd(node, value) ? value : '';\n  }\n}\n\nexport default StyleAttributor;\n","import { Formattable } from '../blot/abstract/blot';\nimport Registry from '../registry';\nimport Scope from '../scope';\nimport Attributor from './attributor';\nimport ClassAttributor from './class';\nimport StyleAttributor from './style';\n\nclass AttributorStore {\n  private attributes: { [key: string]: Attributor } = {};\n  private domNode: HTMLElement;\n\n  constructor(domNode: HTMLElement) {\n    this.domNode = domNode;\n    this.build();\n  }\n\n  public attribute(attribute: Attributor, value: any): void {\n    // verb\n    if (value) {\n      if (attribute.add(this.domNode, value)) {\n        if (attribute.value(this.domNode) != null) {\n          this.attributes[attribute.attrName] = attribute;\n        } else {\n          delete this.attributes[attribute.attrName];\n        }\n      }\n    } else {\n      attribute.remove(this.domNode);\n      delete this.attributes[attribute.attrName];\n    }\n  }\n\n  public build(): void {\n    this.attributes = {};\n    const blot = Registry.find(this.domNode);\n    if (blot == null) {\n      return;\n    }\n    const attributes = Attributor.keys(this.domNode);\n    const classes = ClassAttributor.keys(this.domNode);\n    const styles = StyleAttributor.keys(this.domNode);\n    attributes\n      .concat(classes)\n      .concat(styles)\n      .forEach((name) => {\n        const attr = blot.scroll.query(name, Scope.ATTRIBUTE);\n        if (attr instanceof Attributor) {\n          this.attributes[attr.attrName] = attr;\n        }\n      });\n  }\n\n  public copy(target: Formattable): void {\n    Object.keys(this.attributes).forEach((key) => {\n      const value = this.attributes[key].value(this.domNode);\n      target.format(key, value);\n    });\n  }\n\n  public move(target: Formattable): void {\n    this.copy(target);\n    Object.keys(this.attributes).forEach((key) => {\n      this.attributes[key].remove(this.domNode);\n    });\n    this.attributes = {};\n  }\n\n  public values(): { [key: string]: any } {\n    return Object.keys(this.attributes).reduce(\n      (attributes: { [key: string]: any }, name: string) => {\n        attributes[name] = this.attributes[name].value(this.domNode);\n        return attributes;\n      },\n      {},\n    );\n  }\n}\n\nexport default AttributorStore;\n","import Attributor from '../attributor/attributor';\nimport AttributorStore from '../attributor/store';\nimport Scope from '../scope';\nimport {\n  Blot,\n  BlotConstructor,\n  Formattable,\n  Parent,\n  Root,\n} from './abstract/blot';\nimport LeafBlot from './abstract/leaf';\nimport ParentBlot from './abstract/parent';\n\n// Shallow object comparison\nfunction isEqual(obj1: object, obj2: object): boolean {\n  if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n    return false;\n  }\n  for (const prop in obj1) {\n    // @ts-expect-error\n    if (obj1[prop] !== obj2[prop]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nclass InlineBlot extends ParentBlot implements Formattable {\n  public static allowedChildren: BlotConstructor[] = [InlineBlot, LeafBlot];\n  public static blotName = 'inline';\n  public static scope = Scope.INLINE_BLOT;\n  public static tagName = 'SPAN';\n\n  public static formats(domNode: HTMLElement, scroll: Root): any {\n    const match = scroll.query(InlineBlot.blotName);\n    if (\n      match != null &&\n      domNode.tagName === (match as BlotConstructor).tagName\n    ) {\n      return undefined;\n    } else if (typeof this.tagName === 'string') {\n      return true;\n    } else if (Array.isArray(this.tagName)) {\n      return domNode.tagName.toLowerCase();\n    }\n    return undefined;\n  }\n\n  protected attributes: AttributorStore;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.attributes = new AttributorStore(this.domNode);\n  }\n\n  public format(name: string, value: any): void {\n    if (name === this.statics.blotName && !value) {\n      this.children.forEach((child) => {\n        if (!(child instanceof InlineBlot)) {\n          child = child.wrap(InlineBlot.blotName, true);\n        }\n        this.attributes.copy(child as InlineBlot);\n      });\n      this.unwrap();\n    } else {\n      const format = this.scroll.query(name, Scope.INLINE);\n      if (format == null) {\n        return;\n      }\n      if (format instanceof Attributor) {\n        this.attributes.attribute(format, value);\n      } else if (\n        value &&\n        (name !== this.statics.blotName || this.formats()[name] !== value)\n      ) {\n        this.replaceWith(name, value);\n      }\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    const formats = this.attributes.values();\n    const format = this.statics.formats(this.domNode, this.scroll);\n    if (format != null) {\n      formats[this.statics.blotName] = format;\n    }\n    return formats;\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (\n      this.formats()[name] != null ||\n      this.scroll.query(name, Scope.ATTRIBUTE)\n    ) {\n      const blot = this.isolate(index, length) as InlineBlot;\n      blot.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    const formats = this.formats();\n    if (Object.keys(formats).length === 0) {\n      return this.unwrap(); // unformatted span\n    }\n    const next = this.next;\n    if (\n      next instanceof InlineBlot &&\n      next.prev === this &&\n      isEqual(formats, next.formats())\n    ) {\n      next.moveChildren(this);\n      next.remove();\n    }\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement = super.replaceWith(name, value) as InlineBlot;\n    this.attributes.copy(replacement);\n    return replacement;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void {\n    super.update(mutations, context);\n    const attributeChanged = mutations.some(\n      (mutation) =>\n        mutation.target === this.domNode && mutation.type === 'attributes',\n    );\n    if (attributeChanged) {\n      this.attributes.build();\n    }\n  }\n\n  public wrap(name: string | Parent, value?: any): Parent {\n    const wrapper = super.wrap(name, value);\n    if (wrapper instanceof InlineBlot) {\n      this.attributes.move(wrapper);\n    }\n    return wrapper;\n  }\n}\n\nexport default InlineBlot;\n","import Attributor from '../attributor/attributor';\nimport AttributorStore from '../attributor/store';\nimport Scope from '../scope';\nimport { Blot, BlotConstructor, Formattable, Root } from './abstract/blot';\nimport LeafBlot from './abstract/leaf';\nimport ParentBlot from './abstract/parent';\nimport InlineBlot from './inline';\n\nclass BlockBlot extends ParentBlot implements Formattable {\n  public static blotName = 'block';\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName = 'P';\n  public static allowedChildren: BlotConstructor[] = [\n    InlineBlot,\n    BlockBlot,\n    LeafBlot,\n  ];\n\n  public static formats(domNode: HTMLElement, scroll: Root): any {\n    const match = scroll.query(BlockBlot.blotName);\n    if (\n      match != null &&\n      domNode.tagName === (match as BlotConstructor).tagName\n    ) {\n      return undefined;\n    } else if (typeof this.tagName === 'string') {\n      return true;\n    } else if (Array.isArray(this.tagName)) {\n      return domNode.tagName.toLowerCase();\n    }\n  }\n\n  protected attributes: AttributorStore;\n\n  constructor(scroll: Root, domNode: Node) {\n    super(scroll, domNode);\n    this.attributes = new AttributorStore(this.domNode);\n  }\n\n  public format(name: string, value: any): void {\n    const format = this.scroll.query(name, Scope.BLOCK);\n    if (format == null) {\n      return;\n    } else if (format instanceof Attributor) {\n      this.attributes.attribute(format, value);\n    } else if (name === this.statics.blotName && !value) {\n      this.replaceWith(BlockBlot.blotName);\n    } else if (\n      value &&\n      (name !== this.statics.blotName || this.formats()[name] !== value)\n    ) {\n      this.replaceWith(name, value);\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    const formats = this.attributes.values();\n    const format = this.statics.formats(this.domNode, this.scroll);\n    if (format != null) {\n      formats[this.statics.blotName] = format;\n    }\n    return formats;\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (this.scroll.query(name, Scope.BLOCK) != null) {\n      this.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    if (def == null || this.scroll.query(value, Scope.INLINE) != null) {\n      // Insert text or inline\n      super.insertAt(index, value, def);\n    } else {\n      const after = this.split(index);\n      if (after != null) {\n        const blot = this.scroll.create(value, def);\n        after.parent.insertBefore(blot, after);\n      } else {\n        throw new Error('Attempt to insertAt after block boundaries');\n      }\n    }\n  }\n\n  public replaceWith(name: string | Blot, value?: any): Blot {\n    const replacement = super.replaceWith(name, value) as BlockBlot;\n    this.attributes.copy(replacement);\n    return replacement;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void {\n    super.update(mutations, context);\n    const attributeChanged = mutations.some(\n      (mutation) =>\n        mutation.target === this.domNode && mutation.type === 'attributes',\n    );\n    if (attributeChanged) {\n      this.attributes.build();\n    }\n  }\n}\n\nexport default BlockBlot;\n","import { Formattable, Root } from './abstract/blot';\nimport LeafBlot from './abstract/leaf';\n\nclass EmbedBlot extends LeafBlot implements Formattable {\n  public static formats(_domNode: HTMLElement, _scroll: Root): any {\n    return undefined;\n  }\n\n  public format(name: string, value: any): void {\n    // super.formatAt wraps, which is what we want in general,\n    // but this allows subclasses to overwrite for formats\n    // that just apply to particular embeds\n    super.formatAt(0, this.length(), name, value);\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    if (index === 0 && length === this.length()) {\n      this.format(name, value);\n    } else {\n      super.formatAt(index, length, name, value);\n    }\n  }\n\n  public formats(): { [index: string]: any } {\n    return this.statics.formats(this.domNode, this.scroll);\n  }\n}\n\nexport default EmbedBlot;\n","import Attributor from '../attributor/attributor';\nimport Registry from '../registry';\nimport Scope from '../scope';\nimport { Blot, BlotConstructor, Root } from './abstract/blot';\nimport ContainerBlot from './abstract/container';\nimport ParentBlot from './abstract/parent';\nimport BlockBlot from './block';\n\nconst OBSERVER_CONFIG = {\n  attributes: true,\n  characterData: true,\n  characterDataOldValue: true,\n  childList: true,\n  subtree: true,\n};\n\nconst MAX_OPTIMIZE_ITERATIONS = 100;\n\nclass ScrollBlot extends ParentBlot implements Root {\n  public static blotName = 'scroll';\n  public static defaultChild = BlockBlot;\n  public static allowedChildren: BlotConstructor[] = [BlockBlot, ContainerBlot];\n  public static scope = Scope.BLOCK_BLOT;\n  public static tagName = 'DIV';\n\n  public registry: Registry;\n  public observer: MutationObserver;\n\n  constructor(registry: Registry, node: HTMLDivElement) {\n    // @ts-expect-error\n    super(null, node);\n    this.registry = registry;\n    this.scroll = this;\n    this.build();\n    this.observer = new MutationObserver((mutations: MutationRecord[]) => {\n      this.update(mutations);\n    });\n    this.observer.observe(this.domNode, OBSERVER_CONFIG);\n    this.attach();\n  }\n\n  public create(input: Node | string | Scope, value?: any): Blot {\n    return this.registry.create(this, input, value);\n  }\n\n  public find(node: Node | null, bubble = false): Blot | null {\n    const blot = this.registry.find(node, bubble);\n    if (!blot) {\n      return null;\n    }\n    if (blot.scroll === this) {\n      return blot;\n    }\n    return bubble ? this.find(blot.scroll.domNode.parentNode, true) : null;\n  }\n\n  public query(\n    query: string | Node | Scope,\n    scope: Scope = Scope.ANY,\n  ): Attributor | BlotConstructor | null {\n    return this.registry.query(query, scope);\n  }\n\n  public register(...definitions: any[]): any {\n    return this.registry.register(...definitions);\n  }\n\n  public build(): void {\n    if (this.scroll == null) {\n      return;\n    }\n    super.build();\n  }\n\n  public detach(): void {\n    super.detach();\n    this.observer.disconnect();\n  }\n\n  public deleteAt(index: number, length: number): void {\n    this.update();\n    if (index === 0 && length === this.length()) {\n      this.children.forEach((child) => {\n        child.remove();\n      });\n    } else {\n      super.deleteAt(index, length);\n    }\n  }\n\n  public formatAt(\n    index: number,\n    length: number,\n    name: string,\n    value: any,\n  ): void {\n    this.update();\n    super.formatAt(index, length, name, value);\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    this.update();\n    super.insertAt(index, value, def);\n  }\n\n  public optimize(context: { [key: string]: any }): void;\n  public optimize(\n    mutations: MutationRecord[],\n    context: { [key: string]: any },\n  ): void;\n  public optimize(mutations: any = [], context: any = {}): void {\n    super.optimize(context);\n    const mutationsMap = context.mutationsMap || new WeakMap();\n    // We must modify mutations directly, cannot make copy and then modify\n    let records = Array.from(this.observer.takeRecords());\n    // Array.push currently seems to be implemented by a non-tail recursive function\n    // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n    while (records.length > 0) {\n      mutations.push(records.pop());\n    }\n    const mark = (blot: Blot | null, markParent = true): void => {\n      if (blot == null || blot === this) {\n        return;\n      }\n      if (blot.domNode.parentNode == null) {\n        return;\n      }\n      if (!mutationsMap.has(blot.domNode)) {\n        mutationsMap.set(blot.domNode, []);\n      }\n      if (markParent) {\n        mark(blot.parent);\n      }\n    };\n    const optimize = (blot: Blot): void => {\n      // Post-order traversal\n      if (!mutationsMap.has(blot.domNode)) {\n        return;\n      }\n      if (blot instanceof ParentBlot) {\n        blot.children.forEach(optimize);\n      }\n      mutationsMap.delete(blot.domNode);\n      blot.optimize(context);\n    };\n    let remaining = mutations;\n    for (let i = 0; remaining.length > 0; i += 1) {\n      if (i >= MAX_OPTIMIZE_ITERATIONS) {\n        throw new Error('[Parchment] Maximum optimize iterations reached');\n      }\n      remaining.forEach((mutation: MutationRecord) => {\n        const blot = this.find(mutation.target, true);\n        if (blot == null) {\n          return;\n        }\n        if (blot.domNode === mutation.target) {\n          if (mutation.type === 'childList') {\n            mark(this.find(mutation.previousSibling, false));\n            Array.from(mutation.addedNodes).forEach((node: Node) => {\n              const child = this.find(node, false);\n              mark(child, false);\n              if (child instanceof ParentBlot) {\n                child.children.forEach((grandChild: Blot) => {\n                  mark(grandChild, false);\n                });\n              }\n            });\n          } else if (mutation.type === 'attributes') {\n            mark(blot.prev);\n          }\n        }\n        mark(blot);\n      });\n      this.children.forEach(optimize);\n      remaining = Array.from(this.observer.takeRecords());\n      records = remaining.slice();\n      while (records.length > 0) {\n        mutations.push(records.pop());\n      }\n    }\n  }\n\n  public update(\n    mutations?: MutationRecord[],\n    context: { [key: string]: any } = {},\n  ): void {\n    mutations = mutations || this.observer.takeRecords();\n    const mutationsMap = new WeakMap();\n    mutations\n      .map((mutation: MutationRecord) => {\n        const blot = this.find(mutation.target, true);\n        if (blot == null) {\n          return null;\n        }\n        if (mutationsMap.has(blot.domNode)) {\n          mutationsMap.get(blot.domNode).push(mutation);\n          return null;\n        } else {\n          mutationsMap.set(blot.domNode, [mutation]);\n          return blot;\n        }\n      })\n      .forEach((blot: Blot | null) => {\n        if (blot != null && blot !== this && mutationsMap.has(blot.domNode)) {\n          blot.update(mutationsMap.get(blot.domNode) || [], context);\n        }\n      });\n    context.mutationsMap = mutationsMap;\n    if (mutationsMap.has(this.domNode)) {\n      super.update(mutationsMap.get(this.domNode), context);\n    }\n    this.optimize(mutations, context);\n  }\n}\n\nexport default ScrollBlot;\n","import Scope from '../scope';\nimport { Blot, Leaf, Root } from './abstract/blot';\nimport LeafBlot from './abstract/leaf';\n\nclass TextBlot extends LeafBlot implements Leaf {\n  public static blotName = 'text';\n  public static scope = Scope.INLINE_BLOT;\n\n  public static create(value: string): Text {\n    return document.createTextNode(value);\n  }\n\n  public static value(domNode: Text): string {\n    return domNode.data;\n  }\n\n  public domNode!: Text;\n  protected text: string;\n\n  constructor(scroll: Root, node: Node) {\n    super(scroll, node);\n    this.text = this.statics.value(this.domNode);\n  }\n\n  public deleteAt(index: number, length: number): void {\n    this.domNode.data = this.text =\n      this.text.slice(0, index) + this.text.slice(index + length);\n  }\n\n  public index(node: Node, offset: number): number {\n    if (this.domNode === node) {\n      return offset;\n    }\n    return -1;\n  }\n\n  public insertAt(index: number, value: string, def?: any): void {\n    if (def == null) {\n      this.text = this.text.slice(0, index) + value + this.text.slice(index);\n      this.domNode.data = this.text;\n    } else {\n      super.insertAt(index, value, def);\n    }\n  }\n\n  public length(): number {\n    return this.text.length;\n  }\n\n  public optimize(context: { [key: string]: any }): void {\n    super.optimize(context);\n    this.text = this.statics.value(this.domNode);\n    if (this.text.length === 0) {\n      this.remove();\n    } else if (this.next instanceof TextBlot && this.next.prev === this) {\n      this.insertAt(this.length(), (this.next as TextBlot).value());\n      this.next.remove();\n    }\n  }\n\n  public position(index: number, _inclusive = false): [Node, number] {\n    return [this.domNode, index];\n  }\n\n  public split(index: number, force = false): Blot | null {\n    if (!force) {\n      if (index === 0) {\n        return this;\n      }\n      if (index === this.length()) {\n        return this.next;\n      }\n    }\n    const after = this.scroll.create(this.domNode.splitText(index));\n    this.parent.insertBefore(after, this.next || undefined);\n    this.text = this.statics.value(this.domNode);\n    return after;\n  }\n\n  public update(\n    mutations: MutationRecord[],\n    _context: { [key: string]: any },\n  ): void {\n    if (\n      mutations.some((mutation) => {\n        return (\n          mutation.type === 'characterData' && mutation.target === this.domNode\n        );\n      })\n    ) {\n      this.text = this.statics.value(this.domNode);\n    }\n  }\n\n  public value(): string {\n    return this.text;\n  }\n}\n\nexport default TextBlot;\n"],"names":["root","factory","exports","module","define","amd","self","window","global","Function","Scope","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","ParchmentError","Error","constructor","message","super","this","name","Registry","attributes","classes","tags","types","static","node","bubble","blots","has","parentNode","err","find","create","scroll","input","match","query","blotClass","Node","nodeType","TEXT_NODE","blot","set","domNode","scope","Text","text","block","inline","Element","getAttribute","split","some","tagName","register","definitions","length","map","d","blotName","attrName","keyName","className","Array","isArray","toUpperCase","forEach","tag","WeakMap","ShadowBlot","prev","next","parseInt","toString","document","createElement","indexOf","classList","add","statics","attach","clone","cloneNode","detach","parent","removeChild","deleteAt","index","isolate","remove","formatAt","wrap","format","insertAt","def","ref","insertBefore","undefined","target","offset","children","optimize","_context","requiredContainer","replaceWith","replacement","_force","update","_mutations","wrapper","appendChild","makeAttachedBlot","e","from","childNodes","child","replaceChild","ParentBlot","uiNode","build","other","attachUI","uiClass","setAttribute","firstChild","head","tail","append","nodes","rest","slice","at","iterator","cur","contains","refNode","curNode","ret","inclusive","callback","forEachAt","startNode","curIndex","curLength","Math","min","reduce","memo","push","filter","reverse","childLength","descendant","criteria","descendants","Number","MAX_VALUE","lengthLeft","childIndex","concat","enforceAllowedChildren","done","allowedChildren","splitAfter","unwrap","childBlot","refBlot","refDomNode","nextSibling","moveChildren","targetParent","context","defaultChild","path","position","force","after","_length","mutations","addedNodes","removedNodes","mutation","type","body","compareDocumentPosition","DOCUMENT_POSITION_CONTAINED_BY","sort","a","b","DOCUMENT_POSITION_FOLLOWING","ContainerBlot","checkMerge","LeafBlot","_domNode","_inclusive","Attributor","options","attributeBit","whitelist","item","canAdd","_node","replace","removeAttribute","prefix","join","camelize","parts","part","trim","style","attribute","keys","styles","attr","copy","move","values","InlineBlot","toLowerCase","formats","obj1","obj2","isEqual","BlockBlot","_scroll","OBSERVER_CONFIG","characterData","characterDataOldValue","childList","subtree","ScrollBlot","registry","observer","MutationObserver","observe","disconnect","mutationsMap","records","takeRecords","pop","mark","markParent","delete","remaining","i","previousSibling","grandChild","TextBlot","createTextNode","data","splitText"],"sourceRoot":""}